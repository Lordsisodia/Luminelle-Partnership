#!/usr/bin/env python3
"""
Set feature-research decisions once and propagate them across the 5 plan folders:
Step 01–04 + Synthesis.

Primary input is the synthesis plan folder; we derive step-plan paths from:
  <synth-plan>/artifacts/sources.md

We update:
  artifacts/feature-research-config.yaml

This intentionally avoids external YAML dependencies by doing conservative, line-based edits
against a known template (generated by start-feature-research.sh).
"""

from __future__ import annotations

import argparse
import os
import re
from pathlib import Path


def read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def write_text(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8")


def extract_step_plan_paths_from_sources(sources_md: str) -> list[str]:
    """
    Matches lines like:
      - Step 01 plan: `...`
    """
    paths: list[str] = []
    for step_num in ("01", "02", "03", "04"):
        m = re.search(rf"^- Step {step_num} plan:\s*`([^`]+)`\s*$", sources_md, re.MULTILINE)
        if m:
            paths.append(m.group(1).strip())
    return paths


def update_config_yaml(text: str, *, target_user_first: str | None, license_policy: str | None) -> str:
    """
    Line-based updates that only touch known keys. Preserves everything else.
    """
    if "# AUTO-GENERATED: feature-research config" not in text:
        raise ValueError("Refusing to edit: config file missing AUTO-GENERATED marker")

    def repl_line(key: str, value: str, s: str) -> str:
        # Replace:   key: "..."
        # or:        key: ...
        pattern = rf"^(\s*{re.escape(key)}:\s*).*$"
        return re.sub(pattern, rf'\1"{value}"', s, flags=re.MULTILINE)

    out = text
    if target_user_first is not None:
        out = repl_line("target_user_first", target_user_first, out)
    if license_policy is not None:
        out = repl_line("license_policy", license_policy, out)
    return out


def update_targets_block(
    text: str,
    *,
    competitors: int | None,
    oss_repos: int | None,
    thin_slices: int | None,
) -> str:
    """
    Updates integer keys under the `targets:` block only.
    This keeps edits conservative without requiring a YAML parser.
    """
    if all(v is None for v in (competitors, oss_repos, thin_slices)):
        return text

    # If there is no targets block at all, append one at the end.
    if re.search(r"^\s*targets:\s*$", text, re.MULTILINE) is None:
        # If caller provides only some values, keep reasonable defaults.
        c = 100 if competitors is None else competitors
        o = 20 if oss_repos is None else oss_repos
        t = 10 if thin_slices is None else thin_slices
        suffix = "\n" if text.endswith("\n") else "\n\n"
        return (
            text
            + suffix
            + "targets:\n"
            + f"  competitors: {c}\n"
            + f"  oss_repos: {o}\n"
            + f"  thin_slices: {t}\n"
        )

    lines = text.splitlines()
    out: list[str] = []
    in_targets = False
    targets_indent = 0

    for raw in lines:
        if not in_targets:
            m = re.match(r"^(\s*)targets:\s*$", raw)
            if m:
                in_targets = True
                targets_indent = len(m.group(1))
                out.append(raw)
                continue
            out.append(raw)
            continue

        # We are inside targets block until indentation drops back to targets_indent or less.
        cur_indent = len(raw) - len(raw.lstrip(" "))
        if cur_indent <= targets_indent and raw.strip() != "":
            in_targets = False
            out.append(raw)
            continue

        # Only replace known keys.
        if competitors is not None and re.match(r"^\s*competitors:\s*\d+\s*(#.*)?$", raw):
            out.append(re.sub(r"^(\s*competitors:\s*)\d+(\s*(#.*)?)$", rf"\g<1>{competitors}\g<2>", raw))
            continue
        if oss_repos is not None and re.match(r"^\s*oss_repos:\s*\d+\s*(#.*)?$", raw):
            out.append(re.sub(r"^(\s*oss_repos:\s*)\d+(\s*(#.*)?)$", rf"\g<1>{oss_repos}\g<2>", raw))
            continue
        if thin_slices is not None and re.match(r"^\s*thin_slices:\s*\d+\s*(#.*)?$", raw):
            out.append(re.sub(r"^(\s*thin_slices:\s*)\d+(\s*(#.*)?)$", rf"\g<1>{thin_slices}\g<2>", raw))
            continue

        out.append(raw)

    return "\n".join(out) + ("\n" if text.endswith("\n") else "")


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--synth-plan", required=True, help="Path to synthesis plan folder under docs/.blackbox/.plans/...")
    ap.add_argument("--target-user-first", help='e.g. "merchant admins" or "internal ops"')
    ap.add_argument("--license-policy", help='e.g. "prefer permissive; flag GPL/AGPL" or "allow GPL/AGPL"')
    ap.add_argument("--target-competitors", type=int, help="Target competitor deep-dives for this run (dashboard KPI).")
    ap.add_argument("--target-oss-repos", type=int, help="Target OSS repos for this run (dashboard KPI).")
    ap.add_argument("--target-thin-slices", type=int, help="Target thin-slice specs for this run (dashboard KPI).")
    args = ap.parse_args()

    synth_plan = Path(args.synth_plan).resolve()
    sources_file = synth_plan / "artifacts" / "sources.md"
    if not sources_file.exists():
        raise SystemExit(f"Missing sources file: {sources_file}")

    sources_md = read_text(sources_file)
    step_plans = extract_step_plan_paths_from_sources(sources_md)
    if len(step_plans) != 4:
        raise SystemExit(
            "Could not determine all step plan paths from synthesis sources.md. "
            "Expected 4 step plans (01–04)."
        )

    plan_paths = step_plans + [str(synth_plan)]

    changed = 0
    for plan_path in plan_paths:
        plan_dir = Path(plan_path).resolve()
        config_file = plan_dir / "artifacts" / "feature-research-config.yaml"
        if not config_file.exists():
            raise SystemExit(f"Missing config file: {config_file}")

        before = read_text(config_file)
        after = update_config_yaml(
            before,
            target_user_first=args.target_user_first,
            license_policy=args.license_policy,
        )
        after = update_targets_block(
            after,
            competitors=args.target_competitors,
            oss_repos=args.target_oss_repos,
            thin_slices=args.target_thin_slices,
        )
        if after != before:
            write_text(config_file, after)
            changed += 1
            print(f"Updated: {config_file}")
        else:
            print(f"No change: {config_file}")

    print(f"Done. Files updated: {changed}/{len(plan_paths)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
