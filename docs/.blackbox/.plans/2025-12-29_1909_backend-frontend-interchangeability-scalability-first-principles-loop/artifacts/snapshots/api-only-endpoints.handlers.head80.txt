### ../api/internal/recovery-cron.ts
import { CART_RECOVERY_CRON_ENABLED } from '../_lib/cartRecovery/env.js'

export default async function handler(_req: Request) {
  if (!CART_RECOVERY_CRON_ENABLED) return new Response('cron disabled', { status: 204 })
  // TODO: hook into Supabase + Resend; for now, return not implemented.
  return new Response('not implemented', { status: 501 })
}

### ../api/og.ts
import type { VercelRequest, VercelResponse } from '@vercel/node'

import { ImageResponse } from '@vercel/og'
import { createElement } from 'react'

function getStringParam(url: URL, key: string, maxLen: number): string | null {
  const value = url.searchParams.get(key)
  if (!value) return null
  return value.slice(0, maxLen)
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  try {
    const host = req.headers.host || 'localhost'
    const url = new URL(req.url || '/', `https://${host}`)

    const title = getStringParam(url, 'title', 100) ?? 'Lumelle'
    const description =
      getStringParam(url, 'description', 200) ??
      'Satin-lined, waterproof shower caps for frizz-free hair.'

    const element = createElement(
      'div',
      {
        style: {
          backgroundColor: '#FDF8F6', // brand-blush/20
          height: '100%',
          width: '100%',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          fontFamily: 'sans-serif',
          padding: '40px',
          border: '20px solid #E6D5D0', // brand-blush
        },
      },
      createElement(
        'div',
        {
          style: {
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            textAlign: 'center',
          },
        },
        createElement(
          'div',
          {
            style: {
              fontSize: 40,
              fontWeight: 900,
              textTransform: 'uppercase',
              letterSpacing: '0.2em',
              color: '#4A3B32', // brand-cocoa
              marginBottom: 20,
            },
          },
          'Lumelle',
        ),
        createElement(
          'div',
          {
            style: {
              fontSize: 60,
              fontWeight: 'bold',
              color: '#4A3B32', // brand-cocoa
              marginBottom: 20,
              lineHeight: 1.2,
            },
          },
          title,
        ),
        createElement(
          'div',
          {
            style: {
              fontSize: 30,

### ../api/orders/list.ts
import { getPgPool } from "../_lib/db.js";
import { mapShopOrderRowToOrder } from "./_map.js";

export default async function handler(_req: Request) {
  const pool = getPgPool();
  const { rows } = await pool.query('SELECT * FROM "ShopOrders" ORDER BY processed_at DESC NULLS LAST, created_at DESC NULLS LAST LIMIT 50');
  const orders = rows.map(mapShopOrderRowToOrder);
  return new Response(JSON.stringify(orders), { headers: { "content-type": "application/json" } });
}

### ../api/shopify/backfill/customers.ts
import { requireInternalAuth } from "../../_lib/internalAuth.js";
import { getAdminToken, adminGraphQL } from "../_admin.js";
import { upsertShopCustomer } from "../../_lib/shopCustomers.js";

export default async function handler(req: Request) {
  const auth = requireInternalAuth(req);
  if (!auth.ok) return new Response("Unauthorized", { status: 401 });
  const url = new URL(req.url);
  const shop = url.searchParams.get("shop");
  if (!shop) return new Response("Missing shop", { status: 400 });
  const token = await getAdminToken(shop);

  let cursor: string | null = null;
  let count = 0;
  // Paginate customers
  for (;;) {
    const data: any = await adminGraphQL<any>(
      shop,
      token,
      `#graphql
      query Customers($first:Int!, $after:String) {
        customers(first: $first, after: $after, sortKey: UPDATED_AT) {
          pageInfo { hasNextPage endCursor }
          edges { node {
            id
            email
            firstName
            lastName
            state
            tags
            createdAt
            updatedAt
            defaultAddress { address1 address2 city country code: countryCode phone province zip }
            addresses(first: 10) { edges { node { address1 address2 city country code: countryCode phone province zip } } }
          } }
        }
      }
      `,
      { first: 100, after: cursor },
    );
    const edges = data.customers.edges as any[];
    for (const { node } of edges) {
      const id = Number(String(node.id).split("/").pop());
      await upsertShopCustomer(shop, {
        id,
        email: node.email,
        first_name: node.firstName,
        last_name: node.lastName,
        state: node.state,
        tags: node.tags,
        created_at: node.createdAt,
        updated_at: node.updatedAt,
        default_address: node.defaultAddress,
        addresses: (node.addresses?.edges || []).map((e: any) => e.node),
      });
      count++;
    }
    if (!data.customers.pageInfo.hasNextPage) break;
    cursor = data.customers.pageInfo.endCursor;
  }
  return new Response(JSON.stringify({ ok: true, count }), { headers: { "content-type": "application/json" } });
}

### ../api/shopify/backfill/orders.ts
import { requireInternalAuth } from "../../_lib/internalAuth.js";
import { getAdminToken, adminGraphQL } from "../_admin.js";
import { upsertShopOrder } from "../../_lib/shopOrders.js";

export default async function handler(req: Request) {
  const auth = requireInternalAuth(req);
  if (!auth.ok) return new Response("Unauthorized", { status: 401 });
  const url = new URL(req.url);
  const shop = url.searchParams.get("shop");
  if (!shop) return new Response("Missing shop", { status: 400 });
  const token = await getAdminToken(shop);

  let cursor: string | null = null;
  let count = 0;
  for (;;) {
    const data: any = await adminGraphQL<any>(
      shop,
      token,
      `#graphql
      query Orders($first:Int!, $after:String) {
        orders(first: $first, after: $after, sortKey: UPDATED_AT) {
          pageInfo { hasNextPage endCursor }
          edges { node {
            id
            name
            email
            createdAt
            updatedAt
            processedAt
            currencyCode
            currentTotalPriceSet { shopMoney { amount currencyCode } }
            currentSubtotalPriceSet { shopMoney { amount currencyCode } }
            financialStatus
            fulfillmentStatus
            lineItems(first: 50) { edges { node { quantity title variant { id title price: priceSet { shopMoney { amount currencyCode } } } } } }
          } }
        }
      }
      `,
      { first: 50, after: cursor },
    );
    const edges = data.orders.edges as any[];
    for (const { node } of edges) {
      const id = Number(String(node.id).split("/").pop());
      const mapLineItems = (node.lineItems?.edges || []).map((e: any) => ({
        title: e.node.title,
        quantity: e.node.quantity,
        variant: {
          id: e.node.variant?.id,
          title: e.node.variant?.title,
          price: e.node.variant?.price?.shopMoney?.amount,
          currency: e.node.variant?.price?.shopMoney?.currencyCode,
        },
      }));
      await upsertShopOrder(shop, {
        id,
        name: node.name,
        email: node.email,
        currency: node.currencyCode,
        subtotal_price: node.currentSubtotalPriceSet?.shopMoney?.amount,
        total_price: node.currentTotalPriceSet?.shopMoney?.amount,
        financial_status: node.financialStatus,
        fulfillment_status: node.fulfillmentStatus,
        processed_at: node.processedAt,
        created_at: node.createdAt,
        updated_at: node.updatedAt,
        line_items: mapLineItems,
      });
      count++;
    }
    if (!data.orders.pageInfo.hasNextPage) break;
    cursor = data.orders.pageInfo.endCursor;
  }
  return new Response(JSON.stringify({ ok: true, count }), { headers: { "content-type": "application/json" } });
}

### ../api/shopify/billing/create.ts
import { ensureShopifySessionTable, getPgPool } from "../../_lib/db.js";

const API_VERSION = process.env.SHOPIFY_API_VERSION || "2025-01";

export default async function handler(req: Request) {
  const url = new URL(req.url);
  const shop = url.searchParams.get("shop");
  const host = url.searchParams.get("host") || "";
  if (!shop) return new Response("Missing shop", { status: 400 });

  const pool = getPgPool();
  await ensureShopifySessionTable()
  const { rows } = await pool.query('SELECT accesstoken FROM "Session" WHERE id = $1 LIMIT 1', [
    `offline_${shop}`,
  ]);
  const token = rows[0]?.accesstoken;
  if (!token) return new Response("No session", { status: 401 });

  const mutation = `#graphql\nmutation CreateSub($name: String!, $returnUrl: URL!, $lineItems: [AppSubscriptionLineItemInput!]!, $test: Boolean!) {\n  appSubscriptionCreate(name: $name, returnUrl: $returnUrl, lineItems: $lineItems, test: $test) {\n    confirmationUrl\n    userErrors { field message }\n  }\n}`;

  const returnUrl = new URL("/shopify/app", url.origin);
  if (host) returnUrl.searchParams.set("host", host);
  returnUrl.searchParams.set("shop", shop);

  const gq = await fetch(`https://${shop}/admin/api/${API_VERSION}/graphql.json`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      "X-Shopify-Access-Token": token,
    },
    body: JSON.stringify({
      query: mutation,
      variables: {
        name: "Lumelle Basic",
        returnUrl: returnUrl.toString(),
        test: true,
        lineItems: [
          { plan: { appRecurringPricingDetails: { price: { amount: 9.99, currencyCode: "USD" }, interval: "EVERY_30_DAYS" } } },
        ],
      },
    }),
  });
  if (!gq.ok) return new Response("GraphQL error", { status: 502 });
  const data = await gq.json();
  const urlRedirect = data?.data?.appSubscriptionCreate?.confirmationUrl;
  if (!urlRedirect) return new Response(JSON.stringify(data), { status: 500, headers: { "content-type": "application/json" } });

  return new Response(null, { status: 302, headers: { Location: urlRedirect } });
}

### ../api/shopify/settings.ts
import { requireInternalAuth } from "../_lib/internalAuth.js";
import { getPgPool } from "../_lib/db.js";

export default async function handler(req: Request) {
  const auth = requireInternalAuth(req);
  if (!auth.ok) {
    return new Response(JSON.stringify({ error: auth.message }), {
      status: auth.status,
      headers: { "content-type": "application/json" },
    });
  }
  const pool = getPgPool();
  await pool.query(
    'CREATE TABLE IF NOT EXISTS "ShopSettings" (shop text PRIMARY KEY, public_message text, updated_at timestamptz DEFAULT now())',
  );

  if (req.method === "GET") {
    const url = new URL(req.url);
    const shop = url.searchParams.get("shop");
    if (!shop) {
      return new Response(JSON.stringify({ error: "Missing shop" }), {
        status: 400,
        headers: { "content-type": "application/json" },
      });
    }
    const { rows } = await pool.query(
      'SELECT public_message FROM "ShopSettings" WHERE shop = $1',
      [shop],
    );
    return new Response(
      JSON.stringify({ publicMessage: rows[0]?.public_message ?? "" }),
      { headers: { "content-type": "application/json" } },
    );
  }

  if (req.method === "POST") {
    const body = await req.json().catch(() => ({}));
    const shop = body.shop as string | undefined;
    const publicMessage = String(body.publicMessage || "");
    if (!shop) {
      return new Response(JSON.stringify({ error: "Missing shop" }), {
        status: 400,
        headers: { "content-type": "application/json" },
      });
    }
    await pool.query(
      'INSERT INTO "ShopSettings" (shop, public_message) VALUES ($1, $2) ON CONFLICT (shop) DO UPDATE SET public_message = excluded.public_message, updated_at = now()',
      [shop, publicMessage],
    );
    return new Response(JSON.stringify({ ok: true }), {
      headers: { "content-type": "application/json" },
    });
  }

  return new Response("Method not allowed", { status: 405 });
}

### ../api/shopify/sync.ts
import { requireInternalAuth } from "../_lib/internalAuth.js";
import { handleSyncForShop } from "../_lib/shopifyCore.js";

export default async function handler(req: Request) {
  const auth = requireInternalAuth(req);
  if (!auth.ok) {
    return new Response(JSON.stringify({ error: auth.message }), {
      status: auth.status,
      headers: { "content-type": "application/json" },
    });
  }
  const body = await req.json().catch(() => ({}));
  const shop: string | undefined = body.shop;
  if (!shop) {
    return new Response(JSON.stringify({ error: "Missing shop" }), {
      status: 400,
      headers: { "content-type": "application/json" },
    });
  }
  const data = await handleSyncForShop(shop);
  return new Response(JSON.stringify(data), {
    headers: { "content-type": "application/json" },
  });
}

### ../api/shopify/webhooks/checkouts-create.ts
import type { VercelRequest, VercelResponse } from '@vercel/node'
import { verifyWebhook } from './_verify.js'
import { upsertCheckout } from '../../_lib/checkouts.js'

export const config = { api: { bodyParser: false } };

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        return res.status(405).send('Method Not Allowed')
    }

    const { valid, body } = await verifyWebhook(req)
    if (!valid) {
        return res.status(401).send('Invalid HMAC')
    }

    console.log('Received Shopify Checkout Create Webhook')
    try {
        await upsertCheckout(body)
        return res.status(200).send('OK')
    } catch (error) {
        console.error('Error processing checkout webhook:', error)
        return res.status(500).send('Error')
    }
}

### ../api/shopify/webhooks/checkouts-update.ts
import type { VercelRequest, VercelResponse } from '@vercel/node'
import { verifyWebhook } from './_verify.js'
import { upsertCheckout } from '../../_lib/checkouts.js'

export const config = { api: { bodyParser: false } };

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        return res.status(405).send('Method Not Allowed')
    }

    const { valid, body } = await verifyWebhook(req)
    if (!valid) {
        return res.status(401).send('Invalid HMAC')
    }

    console.log('Received Shopify Checkout Update Webhook')
    try {
        await upsertCheckout(body)
        return res.status(200).send('OK')
    } catch (error) {
        console.error('Error processing checkout webhook:', error)
        return res.status(500).send('Error')
    }
}

### ../api/shopify/webhooks/products_create.ts
import { verifyWebhook } from "./_verify.js";
import { getPgPool } from "../../_lib/db.js";

import type { VercelRequest, VercelResponse } from '@vercel/node'

export const config = { api: { bodyParser: false } };

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== "POST") {
        return res.status(405).send("Method not allowed");
    }

    // Verify webhook signature
    // Note: We need to read the body as text for verification, then parse JSON
    // const rawBody = await req.text(); // No longer needed directly here, verifyWebhook handles it
    // const hmac = req.headers.get("X-Shopify-Hmac-Sha256"); // No longer needed directly here
    const secret = process.env.SHOPIFY_API_SECRET;

    if (!secret) {
        console.error("SHOPIFY_API_SECRET is not set");
        return res.status(500).send("Server Error");
    }

    const { valid, body, rawBody } = await verifyWebhook(req);
    if (!valid) {
        return res.status(401).send("Invalid HMAC");
    }

    const topic = (req.headers['x-shopify-topic'] || '') as string;
    const shop = (req.headers['x-shopify-shop-domain'] || body?.domain || body?.shop_domain) as string;

    console.log(`Received webhook ${topic} for ${shop}`);

    if (!rawBody) return res.status(400).send("Missing body");
    const product = JSON.parse(rawBody);
    const pool = getPgPool();

    // Map Shopify product to our schema
    // id is uuid in our DB, but Shopify ID is a number (e.g. 123456789)
    // We might need to store Shopify ID in a separate column or use a deterministic UUID based on Shopify ID
    // For now, let's assume we check if a product with this SKU exists, or we need to add a shopify_id column to products table.
    // The schema in Step 90 shows: id uuid primary key default gen_random_uuid(), sku text unique not null.
    // It doesn't have shopify_id.
    // We should probably use SKU as the key if it's unique and consistent.

    const sku = product.variants?.[0]?.sku || `SHOPIFY-${product.id}`;
    const price = product.variants?.[0]?.price || 0;
    const imageUrl = product.image?.src || product.images?.[0]?.src || null;

    try {
        await pool.query(
            `INSERT INTO products (sku, title, description, price, image_url, tags, is_active, updated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
       ON CONFLICT (sku) DO UPDATE SET
         title = EXCLUDED.title,
         description = EXCLUDED.description,
         price = EXCLUDED.price,
         image_url = EXCLUDED.image_url,
         tags = EXCLUDED.tags,
         is_active = EXCLUDED.is_active,
         updated_at = NOW()`,
            [
                sku,
                product.title,
                product.body_html,
                price,
                imageUrl,
                product.tags ? product.tags.split(",").map((t: string) => t.trim()) : [],
                product.status === "active",
            ]
        );
        return res.status(200).send("OK");
    } catch (e) {
        console.error("Error syncing product:", e);
        return res.status(500).send("Internal Server Error");
    }
}

### ../api/storefront/cart/restore.ts
import { CART_RECOVERY_ENABLED, CART_RECOVERY_SECRET } from '../../_lib/cartRecovery/env.js'
import { verifyRestoreToken } from '../../_lib/cartRecovery/token.js'

export default async function handler(req: Request) {
  if (!CART_RECOVERY_ENABLED) return new Response('disabled', { status: 404 })
  if (!CART_RECOVERY_SECRET) return new Response('missing secret', { status: 500 })

  const body = await req.json().catch(() => ({} as any))
  const token = body.token as string | undefined
  if (!token) return new Response('missing token', { status: 400 })

  const payload = verifyRestoreToken(token, CART_RECOVERY_SECRET)
  if (!payload) return new Response('invalid or expired token', { status: 401 })

  // TODO: load snapshot or cart by payload.cartId/payload.snapshotRef
  // TODO: fetch/create Shopify cart and replay lines/discounts/email
  return new Response(JSON.stringify({ checkoutUrl: '/checkout', cartId: payload.cartId ?? 'restored-cart' }), {
    headers: { 'content-type': 'application/json' },
  })
}

### ../api/storefront/cart/share.ts
import { randomUUID } from 'crypto'

import { CART_RECOVERY_ENABLED, CART_RECOVERY_SECRET } from '../../_lib/cartRecovery/env.js'
import { signRestoreToken, type RestorePayload } from '../../_lib/cartRecovery/token.js'

export default async function handler(req: Request) {
  if (!CART_RECOVERY_ENABLED) return new Response('disabled', { status: 404 })
  if (!CART_RECOVERY_SECRET) return new Response('missing secret', { status: 500 })

  const body = await req.json().catch(() => ({} as any))
  const { cartId, snapshot, restoreBaseUrl } = body
  if (!cartId && !snapshot) return new Response('missing cartId or snapshot', { status: 400 })

  // TODO: store snapshot or cartId ref in Supabase/R2 and use snapshotRef instead of inline snapshot.
  const payload: RestorePayload = {
    cartId,
    snapshotRef: snapshot ? 'inline' : undefined,
    issuedAt: Date.now(),
    expiresAt: Date.now() + 14 * 24 * 60 * 60 * 1000,
    nonce: randomUUID(),
    v: 1,
  }

  const token = signRestoreToken(payload, CART_RECOVERY_SECRET)
  const base = restoreBaseUrl || 'https://example.com/cart'
  const url = `${base}?restore=${encodeURIComponent(token)}`

  return new Response(JSON.stringify({ restoreUrl: url, token }), { headers: { 'content-type': 'application/json' } })
}

