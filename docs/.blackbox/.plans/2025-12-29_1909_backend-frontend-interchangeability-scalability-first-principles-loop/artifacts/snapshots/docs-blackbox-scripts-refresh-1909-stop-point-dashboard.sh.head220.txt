#!/usr/bin/env bash
set -euo pipefail

# Generates/refreshes a stop-point progress dashboard for the 1909 plan.
#
# It is intentionally simple:
# - Reads `context/pr-diffs/*.md` (excluding README.md)
# - Writes `stop-point-status-dashboard.md` in the plan root
#
# Run from `docs/`.
#
# Usage:
#   ./.blackbox/scripts/refresh-1909-stop-point-dashboard.sh
#
# Optional:
#   PLAN=... override plan folder (defaults to 1909 plan)

if [[ "${PWD##*/}" != "docs" ]]; then
  echo "error: run this script from the docs/ directory (current: $PWD)" >&2
  exit 2
fi

PLAN="${PLAN:-.blackbox/.plans/2025-12-29_1909_backend-frontend-interchangeability-scalability-first-principles-loop}"
PR_DIFFS_DIR="$PLAN/context/pr-diffs"
OUT="$PLAN/stop-point-status-dashboard.md"
SNP="$PLAN/artifacts/snapshots"

mkdir -p "$PR_DIFFS_DIR"
mkdir -p "$SNP"

ts_compact="$(date -u +%Y-%m-%d_%H%M%S)"
log_file="$SNP/refresh-1909-stop-point-dashboard.${ts_compact}.log.txt"
exec > >(tee "$log_file") 2>&1
echo "log: $log_file"

ts="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

echo "# Stop-Point Status Dashboard (1909)" > "$OUT"
echo "" >> "$OUT"
echo "- Updated: \`$ts\`" >> "$OUT"
echo "- Source of truth for PR completion: \`$PR_DIFFS_DIR/\`" >> "$OUT"
echo "" >> "$OUT"
echo "## Filled PR diffs (newest first)" >> "$OUT"
echo "" >> "$OUT"

count=0
completed_prs_tmp="$(mktemp)"
trap 'rm -f "$completed_prs_tmp"' EXIT
while IFS= read -r f; do
  bn="$(basename "$f")"
  [[ "$bn" == "README.md" ]] && continue
  [[ "$bn" == ".keep" ]] && continue
  [[ "$bn" == _* ]] && continue
  [[ "$bn" == *template* ]] && continue
  echo "- \`context/pr-diffs/$bn\`" >> "$OUT"
  count=$((count+1))
  echo "$bn" >> "$completed_prs_tmp"
done < <(ls -1t "$PR_DIFFS_DIR"/*.md 2>/dev/null || true)

if [[ $count -eq 0 ]]; then
  echo "- (none yet — add one by copying \`pr-evidence-diff-summary-template.md\`)" >> "$OUT"
fi

echo "" >> "$OUT"
echo "## Stop points (manual checklist)" >> "$OUT"
echo "" >> "$OUT"
checkbox () {
  local pr="$1"
  # Works on macOS bash 3.2 (no associative arrays).
  # Matches filenames like: *_pr-000_*.md or *_pr-7_*.md
  if grep -Eq "pr-0*${pr}_" "$completed_prs_tmp" 2>/dev/null; then
    echo "[x]"
  else
    echo "[ ]"
  fi
}

latest_diff_for_pr () {
  local pr="$1"
  # Return latest diff filename (relative) for a given PR number, or empty if none.
  # Relies on `ls -1t` order and filename pattern `*_pr-<number>_*.md`.
  local match
  match="$(ls -1t "$PR_DIFFS_DIR"/*.md 2>/dev/null | xargs -n 1 basename | grep -E "pr-0*${pr}_" | head -n 1 || true)"
  if [[ -n "$match" ]]; then
    echo "context/pr-diffs/$match"
  fi
}

render_pr_line () {
  local pr="$1"
  local label="$2"
  local link
  link="$(latest_diff_for_pr "$pr")"
  if [[ -n "$link" ]]; then
    echo "- $(checkbox "$pr") PR $pr — $label — \`$link\`"
  else
    echo "- $(checkbox "$pr") PR $pr — $label"
  fi
}

latest_diff_for_p0_3 () {
  local match
  # Prefer a non-template diff file if one exists; fall back to a template link.
  match="$(ls -1t "$PR_DIFFS_DIR"/*.md 2>/dev/null | xargs -n 1 basename | grep -E "p0-3_" | grep -v "template" | head -n 1 || true)"
  if [[ -z "$match" ]]; then
    match="$(ls -1t "$PR_DIFFS_DIR"/*.md 2>/dev/null | xargs -n 1 basename | grep -E "p0-3_" | head -n 1 || true)"
  fi
  if [[ -n "$match" ]]; then
    echo "context/pr-diffs/$match"
  fi
}

checkbox_p0_3 () {
  if grep -Eq "p0-3_" "$completed_prs_tmp" 2>/dev/null; then
    echo "[x]"
  else
    echo "[ ]"
  fi
}

render_p0_3_line () {
  local label="$1"
  local link
  link="$(latest_diff_for_p0_3)"
  if [[ -n "$link" ]]; then
    echo "- $(checkbox_p0_3) P0.3 — $label — \`$link\`"
  else
    echo "- $(checkbox_p0_3) P0.3 — $label"
  fi
}

render_pr_line 0 "Repo hygiene (optional)" >> "$OUT"
render_p0_3_line "Consolidate backend boundary surface (api/** → functions/api/**)" >> "$OUT"
render_pr_line 1 "Add shared boundary primitives (tenant/auth/cache scaffolding)" >> "$OUT"
render_pr_line 2 "Wire auth guards into admin/exports/metrics/orders" >> "$OUT"
render_pr_line 3 "Wire tenant resolution into tenant-scoped endpoints" >> "$OUT"
render_pr_line 4 "Normalize cache headers for public endpoints" >> "$OUT"
render_pr_line 5 "Add tenancy tables (Supabase)" >> "$OUT"
render_pr_line 6 "Provider config lookup: env → tenant_integrations" >> "$OUT"
render_pr_line 7 "Eliminate vendor ID leaks above adapters (key mapping)" >> "$OUT"
render_pr_line 8 "Onboard tenant #2" >> "$OUT"

cat >> "$OUT" <<'MD'

Notes:
- Checkboxes are auto-marked based on diff files in `context/pr-diffs/`:
  - PRs: `*_pr-<number>_*.md`
  - P0.3: `*_p0-3_*.md`
- This is a lightweight signal, not a substitute for code review.
MD

echo "" >> "$OUT"
echo "## At-risk signals (from latest gate outputs)" >> "$OUT"
echo "" >> "$OUT"

vendor_leaks_file="$PLAN/artifacts/snapshots/check-vendor-leaks.txt"
adapter_imports_file="$PLAN/artifacts/snapshots/boundary-adapter-imports.ui-client.rg.txt"
gaps_report_file="$PLAN/contract-gaps-report-v1.1.md"
drift_file="$PLAN/artifacts/snapshots/api-vs-functions.summary.txt"
api_only_usage_file="$PLAN/artifacts/snapshots/api-only-endpoints.exact-usage.latest.txt"
vendor_sdk_imports_file="$PLAN/artifacts/snapshots/boundary-vendor-sdk-imports.nonplatform.rg.txt"

metrics_prev_file="$PLAN/artifacts/snapshots/stop-point-metrics.prev.txt"
metrics_latest_file="$PLAN/artifacts/snapshots/stop-point-metrics.latest.txt"

checkout_proxy_cart_file="$PLAN/artifacts/snapshots/functions-cart-c-catchall.ts.head200.txt"
checkout_proxy_checkouts_file="$PLAN/artifacts/snapshots/functions-checkouts-catchall.ts.head200.txt"
checkout_proxy_lib_file="$PLAN/artifacts/snapshots/functions-_lib-shopifyCheckoutProxy.ts.head240.txt"

vendor_leaks_count="unknown"
if [[ -f "$vendor_leaks_file" ]]; then
  vendor_leaks_count="$(grep -Eo 'disallowed_lines=[0-9]+' "$vendor_leaks_file" | tail -n 1 | cut -d= -f2 || true)"
  [[ -z "$vendor_leaks_count" ]] && vendor_leaks_count="unknown"
fi

checkout_proxy_missing="unknown"
missing_count=0
if [[ -f "$checkout_proxy_cart_file" && -s "$checkout_proxy_cart_file" ]]; then :; else missing_count=$((missing_count+1)); fi
if [[ -f "$checkout_proxy_checkouts_file" && -s "$checkout_proxy_checkouts_file" ]]; then :; else missing_count=$((missing_count+1)); fi
if [[ -f "$checkout_proxy_lib_file" && -s "$checkout_proxy_lib_file" ]]; then :; else missing_count=$((missing_count+1)); fi
checkout_proxy_missing="$missing_count"

adapter_imports_violations="unknown"
if [[ -f "$adapter_imports_file" ]]; then
  # Count non-empty, non-comment lines without failing under `set -e` when the file is empty.
  adapter_imports_violations="$(awk '
    $0 ~ /^[[:space:]]*#/ {next}
    $0 ~ /^[[:space:]]*$/ {next}
    {c++}
    END {print c+0}
  ' "$adapter_imports_file")"
fi

api_only_endpoints="unknown"
if [[ -f "$drift_file" ]]; then
  api_only_endpoints="$(awk '/^api_only:/ {print $2; exit}' "$drift_file" || true)"
  [[ -z "$api_only_endpoints" ]] && api_only_endpoints="unknown"
fi

api_only_used_by_src="unknown"
api_only_used_by_scripts="unknown"
if [[ -f "$api_only_usage_file" ]]; then
  api_only_used_by_src="$(awk '
    BEGIN {count=0; seen=0; used=0}
    /^=== exact: / {
      if (seen && used) count++
      seen=1
      used=0
      next
    }
    index($0, "../src/") == 1 { used=1 }
    END {
      if (seen && used) count++
      print count+0
    }
  ' "$api_only_usage_file")"
  api_only_used_by_scripts="$(awk '
    BEGIN {count=0; seen=0; used=0}
    /^=== exact: / {
      if (seen && used) count++
