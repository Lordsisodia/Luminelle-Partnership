# source: 05-planning/research/ui-infra-key-mapping-strategy.md
# captured: 2025-12-30T10:30:35Z

# Internal Key Mapping Strategy (remove `gid://shopify/...` from UI)

Goal: make the UI interchangeable by ensuring **no UI/provider/config** stores vendor IDs (Shopify GIDs today; other provider IDs later).

Source run folder:
- `docs/.blackbox/.plans/2025-12-28_2014_deep-research-architecture-ui-infra-plug-in-ports-adapters`

---

## Problem statement

Today there are still `gid://shopify/...` strings living above the adapter boundary:
- UI/provider:
  - `src/ui/providers/DrawerProvider.tsx`
- Client config / client-domain logic:
  - `src/domains/client/shop/products/data/product-config.ts`
  - `src/domains/client/shop/cart/logic/volumeDiscounts.ts`

Even if the rest of commerce is port-driven, these hardcoded vendor IDs:
- prevent “swap Shopify → Stripe” without touching UI/config
- create accidental coupling (anyone can copy/paste a new GID into UI)
- make cross-provider behavior undefined (Stripe won’t have Shopify variant GIDs)

---

## North star

Above the adapter boundary, the app speaks **internal keys**:
- `ProductKey` (string)
- `VariantKey` (string)
- `CartKey` / `CartLineKey` (opaque strings)

The adapter owns mapping:
- `VariantKey` ⇄ vendor identifier (Shopify variant GID today)

This is already consistent with the platform primitives:
- `src/domains/platform/ports/primitives.ts`

---

## Recommended approach (v1)

### 1) Treat internal keys as the currency everywhere above adapters

Rule:
- UI and client config store only `VariantKey` and `ProductKey` values.
- No vendor IDs in UI, providers, or client config.

### 2) Implement a single mapping registry at the platform boundary

Create a single “registry” module that maps internal keys to vendor IDs for the active provider.

Design requirements:
- Centralized: there is one authoritative mapping table (avoid “one-off maps” sprinkled around the app).
- Explicit failures: if a key is missing, throw `PortError('NOT_FOUND')` from the adapter layer.
- Auditable: it should be easy to list all keys in use and check if a mapping exists.

### 3) Keep mapping responsibility where it belongs

Where mapping should live:
- In the provider adapter layer (e.g. Shopify adapter code), or in a platform-level resolver that the adapter calls.

Where mapping should not live:
- UI/provider layers
- client-domain “logic” files that are meant to be vendor-agnostic

---

## Naming scheme (suggested)

Keep it boring and deterministic:
- `product.<handle>` for products
- `variant.<handle>.<variant>` for variants

Examples:
- `product.shower-cap`
- `variant.shower-cap.default`
- `variant.heatless-curler.pink`

If you already use handles as keys, you can skip the `product.` prefix, but be consistent.

---

## Migration plan (safe, incremental)

1) Inventory all `gid://shopify/...` occurrences and classify:
   - UI/provider
   - client config/logic
   - platform adapter (allowed)
2) Introduce internal keys in config:
   - replace `fallbackVariantId` (GID) with `fallbackVariantKey` (internal key), etc.
3) Add Shopify mapping table in the adapter layer:
   - `VariantKey` → Shopify variant GID
4) Update call sites to use internal keys only.
5) Add a guardrail check (later):
   - forbid `gid://shopify/` in UI/provider/config directories

---

## “Done” definition

- No `gid://shopify/...` strings exist in UI/providers or client config.
- All UI/cart code uses internal keys (`VariantKey`) above the platform boundary.
- Missing mappings fail loudly inside the adapter layer with `PortError('NOT_FOUND')`.

