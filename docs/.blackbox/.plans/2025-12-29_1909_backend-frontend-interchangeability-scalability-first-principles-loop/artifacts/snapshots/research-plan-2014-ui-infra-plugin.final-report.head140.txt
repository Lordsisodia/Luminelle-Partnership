# source: .blackbox/.plans/2025-12-28_2014_deep-research-architecture-ui-infra-plug-in-ports-adapters/final-report.md
# captured: 2025-12-30T23:54:29Z

# Final Report — UI ↔ Infrastructure Plug‑In Architecture (Shopify now, Stripe later)

Scope: **read-only architecture research** (no code changes in this run).

## 1) What we’re solving

We want a design where:
- UI components are interchangeable (swappable UI / themes / surface components)
- Commerce infrastructure is a plug-in (Shopify today, Stripe later)
- UI never needs to import vendor-specific code, vendor IDs, or vendor copy

## 2) What’s true in the current codebase (evidence)

The repo already has the right *shape* (ports + adapter runtime exist), but there are still **leaks** where UI/domain code stores vendor IDs or contains vendor-specific copy.

Primary coupling points (see also `artifact-map.md` and `artifacts/sources.md`):
- `src/domains/platform/commerce/runtime.ts` — central adapter selection + capability model (good)
- `src/domains/platform/commerce/ports/*` — stable contracts + DTOs (good)
- `src/domains/platform/commerce/adapters/shopify/internal-api/*` — Shopify adapter behind internal API (good)
- `src/domains/client/shop/cart/providers/CartContext.tsx` — mostly port-driven, but still has legacy Shopify GID cleanup + local storage migration logic (expected)
- `src/lib/product.ts` — shared lib is port-driven (`commerce.catalog.getProductByHandle`), but verify upstream callers don’t re-introduce vendor IDs
- `src/lib/sections.ts` — shared lib is port-driven (`content.sections.getLandingSections()`), but verify UI doesn’t hardcode vendor section assumptions
- `src/ui/providers/DrawerProvider.tsx` — Shopify GIDs and vendor-specific assumptions in UI/provider layer (leak)
- `src/domains/client/shop/cart/logic/volumeDiscounts.ts` — hardcoded Shopify variant IDs (leak)

Future provider note:
- Payments already have a `Ports + runtime` pattern too:
  - `src/domains/platform/payments/runtime.ts`
  - `src/domains/platform/payments/adapters/stripe/index.ts`

## 3) Target architecture (ports/adapters)

North star layering (imports flow top → bottom only):

1) **UI** (`src/domains/*/ui/**`, `src/ui/**`)
   - Renders view models, dispatches actions.
   - Must not import vendor adapters (Shopify/Stripe SDKs, Storefront queries, etc).

2) **Domain logic** (`src/domains/*/logic/**`, domain providers/hooks)
   - Business behavior and orchestration.
   - Depends on platform **ports** only.

3) **Platform ports (contracts)** (`src/domains/platform/**/ports/**` + stable public exports)
   - Stable interfaces + DTOs + capability flags.
   - Used by UI/domain logic.

4) **Vendor adapters** (`src/domains/platform/**/adapters/<vendor>/**`)
   - Shopify adapter today.
   - Stripe adapter later.
   - Mock adapter for dev/tests.

Key idea:
- Shopify is current backbone, but UI never knows that.
- UI knows only “checkout mode: redirect/embedded”, “provider label”, “supports discounts”, etc.

## 4) Contract catalog (ports)

Minimum ports for “UI is plug‑in”:

Full draft contracts (interfaces + DTOs + capability flags) live in:
- `ports.md`

### `CatalogPort`
- Purpose: fetch product data needed for PDP/search/upsells without Shopify GraphQL types leaking.
- Minimum methods:
  - `getProductByHandle(handle): Promise<ProductDTO>`
  - (optional) `getProductsByQuery(query): Promise<ProductDTO[]>`

### `CartPort`
- Purpose: cart state + mutations without UI depending on Shopify cart semantics.
- Minimum methods:
  - `getCart(): Promise<CartDTO>`
  - `addLine({ variantKey, qty }): Promise<CartDTO>`
  - `updateLine({ lineKey, qty }): Promise<CartDTO>`
  - `removeLine({ lineKey }): Promise<CartDTO>`
  - optional: `applyDiscount(code)`, `setBuyerIdentity(email)`, `setAttributes(attrs)`

### `CheckoutPort`
- Purpose: start checkout in a vendor-agnostic way.
- Minimum methods:
  - `getCapabilities(): CheckoutCapabilities`
  - `beginCheckout(): Promise<CheckoutStart>`

### `ContentPort` (sections/content blocks)
- Purpose: landing/PDP sections not hardwired to Shopify metaobjects.
- Minimum methods:
  - `getLandingSections(): Promise<SectionsDTO>`
  - (optional) `getPdpSections(productKey): Promise<SectionsDTO>`

## 5) Capability model (so UI doesn’t hardcode Shopify)

UI must not show “Shopify checkout…” copy. It should render based on capabilities.

Example shape (design only):
- `CheckoutCapabilities`:
  - `mode: "redirect" | "embedded" | "none"`
  - `providerLabel?: string` (e.g. “Secure checkout” or “Secure checkout (Shopify)” if you want it visible)
  - `supportsDiscounts: boolean`
  - `supportsBuyerIdentity: boolean`
  - `handoff?: { routes: string[] }` — optional vendor-agnostic “checkout link handling” routes (in this repo: `'/cart/c/*'`, `'/checkouts/*'`)

Default behavior:
- If `CheckoutCapabilities.handoff` exists, `CheckoutPort.beginCheckout()` should return a **first-party** URL whenever possible (proxy/handoff), so UI never needs to know vendor hostnames or vendor route rules.

## 6) Dependency rules (import policy)

Enforce these rules to enable interchangeability:
- UI/domain code must not import `@platform/commerce/shopify/*` directly.
- UI must not embed vendor IDs (e.g. Shopify `gid://shopify/...`) as primary identifiers.
- Vendor-specific copy is not hardcoded in UI; copy is generic + optional provider label from capabilities.
- Domain logic consumes ports; adapters consume vendors.

## 7) Migration plan (high-level)

See `rankings.md` for prioritized steps. The key sequencing principle:
1) Define ports + DTOs (no behavior change)
2) Introduce adapter selection (one platform entrypoint)
3) Move Shopify imports out of UI/shared libs behind ports
4) Remove vendor IDs/copy from UI using capability flags

## 8) Handoff (what to do next when code changes are allowed)

Week 1 (first implementation sprint):
1) Add port interfaces + DTOs in platform (no adapter swap yet).
2) Create a “shopify adapter implements ports” layer (thin wrapper around existing Shopify code).
3) Change a single consumer at a time (start with `src/lib/product.ts` and `src/lib/sections.ts`).

Merge milestones (Stop points 1–8):
- Use the stop-points plan for safe pause/resume:
  - `docs/.blackbox/.plans/2025-12-28_2014_deep-research-architecture-ui-infra-plug-in-ports-adapters/stop-points-and-risks.md`
  - (If you later want a docs-wide milestone tracker, promote one from this plan.)

Avoid:
- Ports that mirror Shopify GraphQL responses (you’ll bake in vendor assumptions).
- UI storing Shopify GIDs as its core identifiers.
- Sprinkling `shopifyEnabled` checks throughout UI—centralize capability checks in the platform entrypoint.

Stripe later:
- Implement the same ports for Stripe (or Stripe+internal checkout), and keep UI driven by capabilities.

