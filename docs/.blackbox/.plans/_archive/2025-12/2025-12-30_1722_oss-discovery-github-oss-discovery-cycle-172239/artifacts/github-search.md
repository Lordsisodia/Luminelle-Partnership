---
status: draft
last_reviewed: 2025-12-30
owner: agent-zero
generated_at_utc: 2025-12-30T10:23:17Z
total_unique_repos: 6
min_stars: 10
include_forks: false
include_archived: false
excluded_results_count: 11
exclude_keywords: cms, headless, content, blog, newsletter, publishing, portfolio, resume, cv, personal site, wordpress, drupal, jekyll, hugo, ghost, strapi, directus, keystone, contentful, course, tutorial
exclude_regex: (?i)\b(cms|headless cms|newsletter|blog|publishing|portfolio|resume|curriculum vitae|personal site)\b
---

# OSS Discovery â€” GitHub search (catalog only)

This tranche is generated from live GitHub search queries (sorted by stars).
Treat license values as **best-effort**; confirm in each repo before adoption.

## ðŸ”Ž Search queries used

- exchange store credit wallet open source stars:>=10 fork:false archived:false
- refund approval workflow open source stars:>=10 fork:false archived:false
- returns warehouse receiving open source stars:>=10 fork:false archived:false
- carrier rate shopping open source stars:>=10 fork:false archived:false
- tracking webhook open source stars:>=10 fork:false archived:false
- fulfillment integration 3pl open source stars:>=10 fork:false archived:false
- shopify tracking app open source stars:>=10 fork:false archived:false
- shopify returns app open source stars:>=10 fork:false archived:false
- shopify fulfillment webhook open source stars:>=10 fork:false archived:false
- Audit log for every change open source stars:>=10 fork:false archived:false
- Role-based access control open source stars:>=10 fork:false archived:false
- Approval workflows for high-impact changes open source stars:>=10 fork:false archived:false
- Funnel analytics open source stars:>=10 fork:false archived:false
- Cohorts and retention curves open source stars:>=10 fork:false archived:false
- Profit margin analytics open source stars:>=10 fork:false archived:false
- Actions mutate Shopify notify create tasks call APIs write to DB open source stars:>=10 fork:false archived:false
- Human-in-the-loop approvals open source stars:>=10 fork:false archived:false
- Retries idempotency deduping open source stars:>=10 fork:false archived:false
- Address validation open source stars:>=10 fork:false archived:false
- Shipping rate logic + carrier integrations open source stars:>=10 fork:false archived:false

## âš¡ Top 25 â€œ<1 week integrationâ€ candidates (heuristic)

| Rank | Repo | Stars | Lang | License | Bucket | Why itâ€™s here |
|---:|---|---:|---|---|---|---|
| 1 | Maor-Oz/Medical-Segmentation-Decathlon-U-net-CNN-with-Generalized-Dice-Coefficient â€” https://github.com/Maor-Oz/Medical-Segmentation-Decathlon-U-net-CNN-with-Generalized-Dice-Coefficient | 23 | Python | UNKNOWN | verify | score=6 (lang+recency+stars+license) |
| 2 | Aryia-Behroziuan/neurons â€” https://github.com/Aryia-Behroziuan/neurons | 74 | N/A | UNKNOWN | verify | score=5 (lang+recency+stars+license) |
| 3 | ramincsy/Best-Coin-Address-Validator- â€” https://github.com/ramincsy/Best-Coin-Address-Validator- | 13 | C# | UNKNOWN | verify | score=5 (lang+recency+stars+license) |
| 4 | GaedoC/AppisPublicas â€” https://github.com/GaedoC/AppisPublicas | 26 | N/A | CC0-1.0 | verify | score=4 (lang+recency+stars+license) |
| 5 | bilde2910/FreeField â€” https://github.com/bilde2910/FreeField | 20 | PHP | Apache-2.0 | safe | score=4 (lang+recency+stars+license) |
| 6 | mercerheather476/turbo-garbanzo â€” https://github.com/mercerheather476/turbo-garbanzo | 26 | N/A | GPL-3.0 | flagged | score=3 (lang+recency+stars+license) |

## ðŸ“š Returns / exchanges / reverse logistics (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|

## ðŸ“š Shipping / tracking / labels / carriers (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|
| GaedoC/AppisPublicas â€” https://github.com/GaedoC/AppisPublicas | 26 | N/A | CC0-1.0 | verify | 2025-11-17T12:40:04Z | Listado de API's PÃºblicas en Chile Listado de API's PÃºblicas para distintos tipos de servicios digitales nacionales  Enlace  Servicios PÃºblicos / Gobierno API Biblioteca del Congreso Leyes, Proyectos de Ley y Normas. API Mercado PÃºblico: Todo lo que necesitas es estar conectado con los servicios de informaciÃ³n disponibles en api.mercadopublico.cl para crear notificaciones y estar siempre actualizado de los negocios con el Estado. API DivisiÃ³n PolÃ­tico Administrativa: Permite obtener Regiones, Provincias y Comunas. API Portal ChileAtiende: API del Portal de Servicios del Estado - ChileAtiende. Plataforma Ley de Lobby La API de la plataforma Ley de Lobby implementada para el Gobierno de Chile, es la interfaz para programadores que permite integrar los contenidos de este portal en tu sitio web. API EnergÃ­a Abierta - ComisiÃ³n Nacional de EnergÃ­a: API permite el acceso directo a los datos publicados en el sitio de datos abiertos de Comision Nacional de EnergÃ­a. API ComisiÃ³n Nacional de EnergÃ­a: Provee el pÃºblico acceso a la informaciÃ³n que se genera dentro de la CNE considerando sus distintos sistemas de informaciÃ³n. Usado en Bencina en lÃ­nea API Datos PeÃ±alolen - Municipalidad de PeÃ±alolen: API que permite el acceso directo a los datos publicados en el sitio de datos abiertos de PeÃ±alolÃ©n. API Datos Providencia - Municipalidad de Providencia: API que permite el acceso directo a los datos publicados en el sitio de datos abiertos de la Municipalidad de Providencia. Compras Transparentes: Desarrollada en Falcon y Python, contiene todos los detalles de la API de Compras Transparentes que permite explorar las transacciones entre el Estado de Chile y las empresas, las cuales se efectÃºan a travÃ©s de la plataforma de compras pÃºblicas. ChileCompra: La API permite el acceso directo a los datos publicados en el portal de datos abiertos de ChileCompra desde tu aplicaciÃ³n. Usa una interfaz RESTful y retorna los datos en formato JSON. Las vistas invocadas a travÃ©s de la API proveen un acceso estÃ¡ndar online a datos contenidos en pÃ¡ginas HTML, XLS, CSV y otros archivos similares disponibles en Internet. Portal de Datos PÃºblicos: La versiÃ³n actual de la API es 1.0. La mayorÃ­a de los mÃ©todos retorna sus resultados en formato JSON, excepto el metodo invoke donde puede elegirse entre varios formatos de salida. Cada key obtenida para la API del Portal de Datos PÃºblicos del Gobierno de Chile estÃ¡ limitada a 10.000 reqs/mes y 1 req/seg. Seguimiento de pedidos de Correos de Chile: MÃ³dulo npm para hacer el seguimiento de uno o mÃ¡s pedidos de Correos de Chile. Correos Chile Tracking API: AfterShip Restful JSON APIs and webhooks allow developers to add Correos Chile tracking function easily. Support APIs Client Libraries for PHP, Java, Node.js, Python, .NET, Ruby. Correos Chile API: EasyPost is a multi-carrier shipping solution. The EasyPost API is one integration point for 60+ carriers, including Correos Chile. Feriados en Chile 2017: API con info de feriados en Chile aÃ±o 2017. Feriados Legales en Chile: API sin restricciones y costos, que contiene todos los feriados legales de Chile. Turnos de Farmacia: URL para obtener en formato JSON el listado de farmacias del paÃ­s y sus turnos nocturnos legales, directamente desde FARMANET del Ministerio de Salud. Transporte BIP: Get balance of bip card (Chile) by scrapping http://www.tarjetabip.cl/ EconomÃ­a Indicadores econÃ³micos diarios: Este es un servicio open source (web service) que entrega los principales indicadores econÃ³micos para Chile en formato JSON. Tanto los indicadores diarios como histÃ³ricos para que desarrolladores puedan utilizarlos en sus aplicaciones o sitios web. Indicadores del DÃ­a: Los indicadores que entregamos en el servicio, aparecen en el sitio del Banco Central de Chile (http://www.bcentral.cl/), estos datos son actualizados cada una hora y servidos en diferentes formatos como xml, json, csv y javascript. API SBIF: La API de SBIF permite obtener informaciÃ³n de manera directa desde la base de datos del sitio web utilizando los servicios web provistos en esta plataforma. Buda.com: La API REST de Buda.com, exchange de criptomonedas por moneda local en Chile, Colombia, PerÃº y Argentina. Permite el manejo de ordenes de compra/venta, abonos/retiros e informaciÃ³n del mercado en tiempo real. BCI: API pÃºblicas del Banco de CrÃ©dito e Inversiones. Permite obtener informaciÃ³n sobre cuentas, indicadores econÃ³micos, informaciÃ³n del banco, entre otros. Medios de Pago Khipu: API REST para crear cobros y recibir pagos con Khipu. Flow: Flow es una plataforma de pagos online que te permite pagar y recibir pagos de cualquier persona usando tarjetas de credito o dÃ©bito. Sistemas de Alerta Sismos Chile: Ãšltimos sismos en Chile. Chile Alerta - Api: Boletines de Tsunami en Chile, Ãšltimos sismos en Chile y Ãšltimos sismos en paÃ­ses especÃ­ficos y el Mundo. Mapas / GeocodificaciÃ³n API Planos.cl: API Planos.cl de hibu estÃ¡ conformada por clases desarrolladas en lenguaje Javascript. API de Mapas y GeocodificaciÃ³n de Mapcity: La API de MapCity es una extensiÃ³n de Openlayers y ExtCore. Los tipos bÃ¡sicos de la API y los controles son derivados de los tipos y controles de OpenLayers, por lo tanto la mayorÃ­a de las funciones de OpenLayers aplican a las funciones de la API. EntretenciÃ³n y ocio HorÃ³scopo Yolanda Sultana: Obtiene el horÃ³scopo del dÃ­a desde Login.cl. No hay forma de obtener horÃ³scopos anteriores, porque es de mala suerte. Clima API Tiempo Meteored.cl: La Api de Meteored.cl es una aplicaciÃ³n con la que usted puede obtener la predicciÃ³n meteorolÃ³gica de las localidades que desee a diario. CÃ³mo Aportar: Seguir el siguiente formato:  - [Nombre / TÃ­tulo sitio web](URL documentaciÃ³n API): DescripciÃ³n corta de quÃ© se trata este servicio, en general se encuentra |
| bilde2910/FreeField â€” https://github.com/bilde2910/FreeField | 20 | PHP | Apache-2.0 | safe | 2025-04-19T22:46:57Z | An open-source mapping and notification tool for PokÃ©mon GO field research quest tracking. |

## ðŸ“š Shopify ops angle (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|

## ðŸ“š Admin UX primitives (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|

## ðŸ“š Analytics (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|

## ðŸ“š Automation / Workflows (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|

## ðŸ“š Checkout / Payments / Taxes (top by stars)

| Repo | Stars | Lang | License | Bucket | Updated | Description |
|---|---:|---|---|---|---|---|
| Aryia-Behroziuan/neurons â€” https://github.com/Aryia-Behroziuan/neurons | 74 | N/A | UNKNOWN | verify | 2025-12-23T02:01:50Z | An ANN is a model based on a collection of connected units or nodes called "artificial neurons", which loosely model the neurons in a biological brain. Each connection, like the synapses in a biological brain, can transmit information, a "signal", from one artificial neuron to another. An artificial neuron that receives a signal can process it and then signal additional artificial neurons connected to it. In common ANN implementations, the signal at a connection between artificial neurons is a real number, and the output of each artificial neuron is computed by some non-linear function of the sum of its inputs. The connections between artificial neurons are called "edges". Artificial neurons and edges typically have a weight that adjusts as learning proceeds. The weight increases or decreases the strength of the signal at a connection. Artificial neurons may have a threshold such that the signal is only sent if the aggregate signal crosses that threshold. Typically, artificial neurons are aggregated into layers. Different layers may perform different kinds of transformations on their inputs. Signals travel from the first layer (the input layer) to the last layer (the output layer), possibly after traversing the layers multiple times.  The original goal of the ANN approach was to solve problems in the same way that a human brain would. However, over time, attention moved to performing specific tasks, leading to deviations from biology. Artificial neural networks have been used on a variety of tasks, including computer vision, speech recognition, machine translation, social network filtering, playing board and video games and medical diagnosis.  Deep learning consists of multiple hidden layers in an artificial neural network. This approach tries to model the way the human brain processes light and sound into vision and hearing. Some successful applications of deep learning are computer vision and speech recognition.[68]  Decision trees Main article: Decision tree learning Decision tree learning uses a decision tree as a predictive model to go from observations about an item (represented in the branches) to conclusions about the item's target value (represented in the leaves). It is one of the predictive modeling approaches used in statistics, data mining, and machine learning. Tree models where the target variable can take a discrete set of values are called classification trees; in these tree structures, leaves represent class labels and branches represent conjunctions of features that lead to those class labels. Decision trees where the target variable can take continuous values (typically real numbers) are called regression trees. In decision analysis, a decision tree can be used to visually and explicitly represent decisions and decision making. In data mining, a decision tree describes data, but the resulting classification tree can be an input for decision making.  Support vector machines Main article: Support vector machines Support vector machines (SVMs), also known as support vector networks, are a set of related supervised learning methods used for classification and regression. Given a set of training examples, each marked as belonging to one of two categories, an SVM training algorithm builds a model that predicts whether a new example falls into one category or the other.[69] An SVM training algorithm is a non-probabilistic, binary, linear classifier, although methods such as Platt scaling exist to use SVM in a probabilistic classification setting. In addition to performing linear classification, SVMs can efficiently perform a non-linear classification using what is called the kernel trick, implicitly mapping their inputs into high-dimensional feature spaces.   Illustration of linear regression on a data set. Regression analysis Main article: Regression analysis Regression analysis encompasses a large variety of statistical methods to estimate the relationship between input variables and their associated features. Its most common form is linear regression, where a single line is drawn to best fit the given data according to a mathematical criterion such as ordinary least squares. The latter is often extended by regularization (mathematics) methods to mitigate overfitting and bias, as in ridge regression. When dealing with non-linear problems, go-to models include polynomial regression (for example, used for trendline fitting in Microsoft Excel[70]), logistic regression (often used in statistical classification) or even kernel regression, which introduces non-linearity by taking advantage of the kernel trick to implicitly map input variables to higher-dimensional space.  Bayesian networks Main article: Bayesian network  A simple Bayesian network. Rain influences whether the sprinkler is activated, and both rain and the sprinkler influence whether the grass is wet. A Bayesian network, belief network, or directed acyclic graphical model is a probabilistic graphical model that represents a set of random variables and their conditional independence with a directed acyclic graph (DAG). For example, a Bayesian network could represent the probabilistic relationships between diseases and symptoms. Given symptoms, the network can be used to compute the probabilities of the presence of various diseases. Efficient algorithms exist that perform inference and learning. Bayesian networks that model sequences of variables, like speech signals or protein sequences, are called dynamic Bayesian networks. Generalizations of Bayesian networks that can represent and solve decision problems under uncertainty are called influence diagrams.  Genetic algorithms Main article: Genetic algorithm A genetic algorithm (GA) is a search algorithm and heuristic technique that mimics the process of natural selection, using methods such as mutation and crossover to generate new genotypes in the hope of finding good solutions to a given problem. In machine learning, genetic algorithms were used in the 1980s and 1990s.[71][72] Conversely, machine learning techniques have been used to improve the performance of genetic and evolutionary algorithms.[73]  Training models Usually, machine learning models require a lot of data in order for them to perform well. Usually, when training a machine learning model, one needs to collect a large, representative sample of data from a training set. Data from the training set can be as varied as a corpus of text, a collection of images, and data collected from individual users of a service. Overfitting is something to watch out for when training a machine learning model.  Federated learning Main article: Federated learning Federated learning is an adapted form of distributed artificial intelligence to training machine learning models that decentralizes the training process, allowing for users' privacy to be maintained by not needing to send their data to a centralized server. This also increases efficiency by decentralizing the training process to many devices. For example, Gboard uses federated machine learning to train search query prediction models on users' mobile phones without having to send individual searches back to Google.[74]  Applications There are many applications for machine learning, including:  Agriculture Anatomy Adaptive websites Affective computing Banking Bioinformatics Brainâ€“machine interfaces Cheminformatics Citizen science Computer networks Computer vision Credit-card fraud detection Data quality DNA sequence classification Economics Financial market analysis[75] General game playing Handwriting recognition Information retrieval Insurance Internet fraud detection Linguistics Machine learning control Machine perception Machine translation Marketing Medical diagnosis Natural language processing Natural language understanding Online advertising Optimization Recommender systems Robot locomotion Search engines Sentiment analysis Sequence mining Software engineering Speech recognition Structural health monitoring Syntactic pattern recognition Telecommunication Theorem proving Time series forecasting User behavior analytics In 2006, the media-services provider Netflix held the first "Netflix Prize" competition to find a program to better predict user preferences and improve the accuracy of its existing Cinematch movie recommendation algorithm by at least 10%. A joint team made up of researchers from AT&T Labs-Research in collaboration with the teams Big Chaos and Pragmatic Theory built an ensemble model to win the Grand Prize in 2009 for $1 million.[76] Shortly after the prize was awarded, Netflix realized that viewers' ratings were not the best indicators of their viewing patterns ("everything is a recommendation") and they changed their recommendation engine accordingly.[77] In 2010 The Wall Street Journal wrote about the firm Rebellion Research and their use of machine learning to predict the financial crisis.[78] In 2012, co-founder of Sun Microsystems, Vinod Khosla, predicted that 80% of medical doctors' jobs would be lost in the next two decades to automated machine learning medical diagnostic software.[79] In 2014, it was reported that a machine learning algorithm had been applied in the field of art history to study fine art paintings and that it may have revealed previously unrecognized influences among artists.[80] In 2019 Springer Nature published the first research book created using machine learning.[81]  Limitations Although machine learning has been transformative in some fields, machine-learning programs often fail to deliver expected results.[82][83][84] Reasons for this are numerous: lack of (suitable) data, lack of access to the data, data bias, privacy problems, badly chosen tasks and algorithms, wrong tools and people, lack of resources, and evaluation problems.[85]  In 2018, a self-driving car from Uber failed to detect a pedestrian, who was killed after a collision.[86] Attempts to use machine learning in healthcare with the IBM Watson system failed to deliver even after years of time and billions of dollars invested.[87][88]  Bias Main article: Algorithmic bias Machine learning approaches in particular can suffer from different data biases. A machine learning system trained on current customers only may not be able to predict the needs of new customer groups that are not represented in the training data. When trained on man-made data, machine learning is likely to pick up the same constitutional and unconscious biases already present in society.[89] Language models learned from data have been shown to contain human-like biases.[90][91] Machine learning systems used for criminal risk assessment have been found to be biased against black people.[92][93] In 2015, Google photos would often tag black people as gorillas,[94] and in 2018 this still was not well resolved, but Google reportedly was still using the workaround to remove all gorillas from the training data, and thus was not able to recognize real gorillas at all.[95] Similar issues with recognizing non-white people have been found in many other systems.[96] In 2016, Microsoft tested a chatbot that learned from Twitter, and it quickly picked up racist and sexist language.[97] Because of such challenges, the effective use of machine learning may take longer to be adopted in other domains.[98] Concern for fairness in machine learning, that is, reducing bias in machine learning and propelling its use for human good is increasingly expressed by artificial intelligence scientists, including Fei-Fei Li, who reminds engineers that "Thereâ€™s nothing artificial about AI...Itâ€™s inspired by people, itâ€™s created by people, andâ€”most importantlyâ€”it impacts people. It is a powerful tool we are only just beginning to understand, and that is a profound responsibility.â€[99]  Model assessments Classification of machine learning models can be validated by accuracy estimation techniques like the holdout method, which splits the data in a training and test set (conventionally 2/3 training set and 1/3 test set designation) and evaluates the performance of the training model on the test set. In comparison, the K-fold-cross-validation method randomly partitions the data into K subsets and then K experiments are performed each respectively considering 1 subset for evaluation and the remaining K-1 subsets for training the model. In addition to the holdout and cross-validation methods, bootstrap, which samples n instances with replacement from the dataset, can be used to assess model accuracy.[100]  In addition to overall accuracy, investigators frequently report sensitivity and specificity meaning True Positive Rate (TPR) and True Negative Rate (TNR) respectively. Similarly, investigators sometimes report the false positive rate (FPR) as well as the false negative rate (FNR). However, these rates are ratios that fail to reveal their numerators and denominators. The total operating characteristic (TOC) is an effective method to express a model's diagnostic ability. TOC shows the numerators and denominators of the previously mentioned rates, thus TOC provides more information than the commonly used receiver operating characteristic (ROC) and ROC's associated area under the curve (AUC).[101]  Ethics Machine learning poses a host of ethical questions. Systems which are trained on datasets collected with biases may exhibit these biases upon use (algorithmic bias), thus digitizing cultural prejudices.[102] For example, using job hiring data from a firm with racist hiring policies may lead to a machine learning system duplicating the bias by scoring job applicants against similarity to previous successful applicants.[103][104] Responsible collection of data and documentation of algorithmic rules used by a system thus is a critical part of machine learning.  Because human languages contain biases, machines trained on language corpora will necessarily also learn these biases.[105][106]  Other forms of ethical challenges, not related to personal biases, are more seen in health care. There are concerns among health care professionals that these systems might not be designed in the public's interest but as income-generating machines. This is especially true in the United States where there is a long-standing ethical dilemma of improving health care, but also increasing profits. For example, the algorithms could be designed to provide patients with unnecessary tests or medication in which the algorithm's proprietary owners hold stakes. There is huge potential for machine learning in health care to provide professionals a great tool to diagnose, medicate, and even plan recovery paths for patients, but this will not happen until the personal biases mentioned previously, and these "greed" biases are addressed.[107]  Hardware Since the 2010s, advances in both machine learning algorithms and computer hardware have led to more efficient methods for training deep neural networks (a particular narrow subdomain of machine learning) that contain many layers of non-linear hidden units.[108] By 2019, graphic processing units (GPUs), often with AI-specific enhancements, had displaced CPUs as the dominant method of training large-scale commercial cloud AI.[109] OpenAI estimated the hardware compute used in the largest deep learning projects from AlexNet (2012) to AlphaZero (2017), and found a 300,000-fold increase in the amount of compute required, with a doubling-time trendline of 3.4 months.[110][111]  Software Software suites containing a variety of machine learning algorithms include the following:  Free and open-source so |
| mercerheather476/turbo-garbanzo â€” https://github.com/mercerheather476/turbo-garbanzo | 26 | N/A | GPL-3.0 | flagged | 2025-11-06T03:08:27Z | ![AppAuth for Android](https://rawgit.com/openid/AppAuth-Android/master/appauth_lockup.svg)  [![Download](https://img.shields.io/maven-central/v/net.openid/appauth)](https://search.maven.org/search?q=g:net.openid%20appauth) [![Javadocs](http://javadoc.io/badge/net.openid/appauth.svg)](http://javadoc.io/doc/net.openid/appauth) [![Build Status](https://github.com/openid/AppAuth-Android/actions/workflows/build.yml/badge.svg)](https://github.com/openid/AppAuth-Android/actions/workflows/build.yml) [![codecov.io](https://codecov.io/github/openid/AppAuth-Android/coverage.svg?branch=master)](https://codecov.io/github/openid/AppAuth-Android?branch=master)  AppAuth for Android is a client SDK for communicating with [OAuth 2.0](https://tools.ietf.org/html/rfc6749) and [OpenID Connect](http://openid.net/specs/openid-connect-core-1_0.html) providers. It strives to directly map the requests and responses of those specifications, while following the idiomatic style of the implementation language. In addition to mapping the raw protocol flows, convenience methods are available to assist with common tasks like performing an action with fresh tokens.  The library follows the best practices set out in [RFC 8252 - OAuth 2.0 for Native Apps](https://tools.ietf.org/html/rfc8252), including using [Custom Tabs](https://developer.chrome.com/multidevice/android/customtabs) for authorization requests. For this reason, `WebView` is explicitly *not* supported due to usability and security reasons.  The library also supports the [PKCE](https://tools.ietf.org/html/rfc7636) extension to OAuth which was created to secure authorization codes in public clients when custom URI scheme redirects are used. The library is friendly to other extensions (standard or otherwise) with the ability to handle additional parameters in all protocol requests and responses.  A talk providing an overview of using the library for enterprise single sign-on (produced by Google) can be found here: [Enterprise SSO with Chrome Custom Tabs](https://www.youtube.com/watch?v=DdQTXrk6YTk).  ## Download  AppAuth for Android is available on [MavenCentral](https://search.maven.org/search?q=g:net.openid%20appauth)  ```groovy implementation 'net.openid:appauth:<version>' ```  ## Requirements  AppAuth supports Android API 16 (Jellybean) and above. Browsers which provide a custom tabs implementation are preferred by the library, but not required. Both Custom URI Schemes (all supported versions of Android) and App Links (Android M / API 23+) can be used with the library.  In general, AppAuth can work with any Authorization Server (AS) that supports native apps as documented in [RFC 8252](https://tools.ietf.org/html/rfc8252), either through custom URI scheme redirects, or App Links. AS's that assume all clients are web-based or require clients to maintain confidentiality of the client secrets may not work well.  ## Demo app  A demo app is contained within this repository. For instructions on how to build and configure this app, see the [demo app readme](https://github.com/openid/AppAuth-Android/blob/master/app/README.md).  ## Conceptual overview  AppAuth encapsulates the authorization state of the user in the [net.openid.appauth.AuthState](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthState.java) class, and communicates with an authorization server through the use of the [net.openid.appauth.AuthorizationService](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationService.java) class. AuthState is designed to be easily persistable as a JSON string, using the storage mechanism of your choice (e.g. [SharedPreferences](https://developer.android.com/training/basics/data-storage/shared-preferences.html), [sqlite](https://developer.android.com/training/basics/data-storage/databases.html), or even just [in a file](https://developer.android.com/training/basics/data-storage/files.html)).  AppAuth provides data classes which are intended to model the OAuth2 specification as closely as possible; this provides the greatest flexibility in interacting with a wide variety of OAuth2 and OpenID Connect implementations.  Authorizing the user occurs via the user's web browser, and the request is described using instances of [AuthorizationRequest](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationRequest.java). The request is dispatched using [performAuthorizationRequest()](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationService.java#L159) on an AuthorizationService instance, and the response (an [AuthorizationResponse](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationResponse.java) instance) will be dispatched to the activity of your choice, expressed via an Intent.  Token requests, such as obtaining a new access token using a refresh token, follow a similar pattern: [TokenRequest](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/TokenRequest.java) instances are dispatched using [performTokenRequest()](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationService.java#L252) on an AuthorizationService instance, and a [TokenResponse](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/TokenResponse.java) instance is returned via a callback.  Responses can be provided to the [update()](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthState.java#L367) methods on AuthState in order to track and persist changes to the authorization state. Once in an authorized state, the [performActionWithFreshTokens()](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthState.java#L449) method on AuthState can be used to automatically refresh access tokens as necessary before performing actions that require valid tokens.  ## Implementing the authorization code flow  It is recommended that native apps use the [authorization code](https://tools.ietf.org/html/rfc6749#section-1.3.1) flow with a public client to gain authorization to access user data. This has the primary advantage for native clients that the authorization flow, which must occur in a browser, only needs to be performed once.  This flow is effectively composed of four stages:  1. Discovering or specifying the endpoints to interact with the provider. 2. Authorizing the user, via a browser, in order to obtain an authorization    code. 3. Exchanging the authorization code with the authorization server, to obtain    a refresh token and/or ID token. 4. Using access tokens derived from the refresh token to interact with a    resource server for further access to user data.  At each step of the process, an AuthState instance can (optionally) be updated with the result to help with tracking the state of the flow.  ### Authorization service configuration  First, AppAuth must be instructed how to interact with the authorization service. This can be done either by directly creating an [AuthorizationServiceConfiguration](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationServiceConfiguration.java#L102) instance, or by retrieving an OpenID Connect discovery document.  Directly specifying an AuthorizationServiceConfiguration involves providing the URIs of the authorization endpoint and token endpoint, and optionally a dynamic client registration endpoint (see "Dynamic client registration" for more info):  ```java AuthorizationServiceConfiguration serviceConfig =     new AuthorizationServiceConfiguration(         Uri.parse("https://idp.example.com/auth"), // authorization endpoint         Uri.parse("https://idp.example.com/token")); // token endpoint ```  Where available, using an OpenID Connect discovery document is preferable:  ```java AuthorizationServiceConfiguration.fetchFromIssuer(     Uri.parse("https://idp.example.com"),     new AuthorizationServiceConfiguration.RetrieveConfigurationCallback() {       public void onFetchConfigurationCompleted(           @Nullable AuthorizationServiceConfiguration serviceConfiguration,           @Nullable AuthorizationException ex) {         if (ex != null) {           Log.e(TAG, "failed to fetch configuration");           return;         }          // use serviceConfiguration as needed     } }); ```  This will attempt to download a discovery document from the standard location under this base URI, `https://idp.example.com/.well-known/openid-configuration`. If the discovery document for your IDP is in some other non-standard location, you can instead provide the full URI as follows:  ```java AuthorizationServiceConfiguration.fetchFromUrl(     Uri.parse("https://idp.example.com/exampletenant/openid-config"),     new AuthorizationServiceConfiguration.RetrieveConfigurationCallback() {         ...     } }); ```  If desired, this configuration can be used to seed an AuthState instance, to persist the configuration easily:  ```java AuthState authState = new AuthState(serviceConfig); ```  ### Obtaining an authorization code  An authorization code can now be acquired by constructing an AuthorizationRequest, using its Builder. In AppAuth, the builders for each data class accept the mandatory parameters via the builder constructor:  ```java AuthorizationRequest.Builder authRequestBuilder =     new AuthorizationRequest.Builder(         serviceConfig, // the authorization service configuration         MY_CLIENT_ID, // the client ID, typically pre-registered and static         ResponseTypeValues.CODE, // the response_type value: we want a code         MY_REDIRECT_URI); // the redirect URI to which the auth response is sent ```  Other optional parameters, such as the OAuth2 [scope string](https://tools.ietf.org/html/rfc6749#section-3.3) or OpenID Connect [login hint](http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1) are specified through set methods on the builder:  ```java AuthorizationRequest authRequest = authRequestBuilder     .setScope("openid email profile https://idp.example.com/custom-scope")     .setLoginHint("jdoe@user.example.com")     .build(); ```  This request can then be dispatched using one of two approaches.  a `startActivityForResult` call using an Intent returned from the `AuthorizationService`, or by calling `performAuthorizationRequest` and providing pending intent for completion and cancelation handling activities.  The `startActivityForResult` approach is simpler to use but may require more processing of the result:  ```java private void doAuthorization() {   AuthorizationService authService = new AuthorizationService(this);   Intent authIntent = authService.getAuthorizationRequestIntent(authRequest);   startActivityForResult(authIntent, RC_AUTH); }  @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {   if (requestCode == RC_AUTH) {     AuthorizationResponse resp = AuthorizationResponse.fromIntent(data);     AuthorizationException ex = AuthorizationException.fromIntent(data);     // ... process the response or exception ...   } else {     // ...   } } ```  If instead you wish to directly transition to another activity on completion or cancelation, you can use `performAuthorizationRequest`:  ```java AuthorizationService authService = new AuthorizationService(this);  authService.performAuthorizationRequest(     authRequest,     PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCompleteActivity.class), 0),     PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCanceledActivity.class), 0)); ```  The intents may be customized to carry any additional data or flags required for the correct handling of the authorization response.  #### Capturing the authorization redirect  Once the authorization flow is completed in the browser, the authorization service will redirect to a URI specified as part of the authorization request, providing the response via query parameters. In order for your app to capture this response, it must register with the Android OS as a handler for this redirect URI.  We recommend using a custom scheme based redirect URI (i.e. those of form `my.scheme:/path`), as this is the most widely supported across all versions of Android. To avoid conflicts with other apps, it is recommended to configure a  distinct scheme using "reverse domain name notation". This can either match your service web domain (in reverse) e.g. `com.example.service` or your package name `com.example.app` or be something completely new as long as it's distinct enough. Using the package name of your app is quite common but it's not always possible if it contains illegal characters for URI schemes (like underscores) or if you already have another handler for that scheme - so just use something else.  When a custom scheme is used, AppAuth can be easily configured to capture all redirects using this custom scheme through a manifest placeholder:  ```groovy android.defaultConfig.manifestPlaceholders = [   'appAuthRedirectScheme': 'com.example.app' ] ```  Alternatively, the redirect URI can be directly configured by adding an intent-filter for AppAuth's RedirectUriReceiverActivity to your AndroidManifest.xml:  ```xml <activity         android:name="net.openid.appauth.RedirectUriReceiverActivity"         tools:node="replace">     <intent-filter>         <action android:name="android.intent.action.VIEW"/>         <category android:name="android.intent.category.DEFAULT"/>         <category android:name="android.intent.category.BROWSABLE"/>         <data android:scheme="com.example.app"/>     </intent-filter> </activity> ```  If an HTTPS redirect URI is required instead of a custom scheme, the same approach (modifying your AndroidManifest.xml) is used:  ```xml <activity         android:name="net.openid.appauth.RedirectUriReceiverActivity"         tools:node="replace">     <intent-filter>         <action android:name="android.intent.action.VIEW"/>         <category android:name="android.intent.category.DEFAULT"/>         <category android:name="android.intent.category.BROWSABLE"/>         <data android:scheme="https"               android:host="app.example.com"               android:path="/oauth2redirect"/>     </intent-filter> </activity> ```  HTTPS redirects can be secured by configuring the redirect URI as an [app link](https://developer.android.com/training/app-links/index.html) in Android M and above. We recommend that a fallback page be configured at the same address to forward authorization responses to your app via a custom scheme, for older Android devices.  #### Handling the authorization response  Upon completion of the authorization flow, the completion Intent provided to performAuthorizationRequest will be triggered. The authorization response is provided to this activity via Intent extra data, which can be extracted using the `fromIntent()` methods on AuthorizationResponse and AuthorizationException respectively:  ```java public void onCreate(Bundle b) {   AuthorizationResponse resp = AuthorizationResponse.fromIntent(getIntent());   AuthorizationException ex = AuthorizationException.fromIntent(getIntent());   if (resp != null) {     // authorization completed   } else {     // authorization failed, check ex for more details   }   // ... } ```  The response can be provided to the AuthState instance for easy persistence and further processing:  ``` authState.update(resp, ex); ```  If the full redirect URI is required in order to extract additional information that AppAuth does not provide, this is also provided to your activity:  ```java public void onCreate(Bundle b) {   // ...   Uri redirectUri = getIntent().getData();   // ... } ```  ### Exchanging the authorization code  Given a successful authorization response carrying an authorization code, a token request can be made to exchange the code for a refresh token:  ```java authService.performTokenRequest(     resp.createTokenExchangeRequest(),     new AuthorizationService.TokenResponseCallback() {       @Override public void onTokenRequestCompleted(             TokenResponse resp, AuthorizationException ex) {           if (resp != null) {             // exchange succeeded           } else {             // authorization failed, check ex for more details           }         }     }); ```  The token response can also be used to update an AuthState instance:  ```java authState.update(resp, ex); ```  ### Using access tokens  Finally, the retrieved access token can be used to interact with a resource server. This can be done directly, by extracting the access token from a token response. However, in most cases, it is simpler to use the `performActionWithFreshTokens` utility method provided by AuthState:  ```java authState.performActionWithFreshTokens(service, new AuthStateAction() {   @Override public void execute(       String accessToken,       String idToken,       AuthorizationException ex) {     if (ex != null) {       // negotiation for fresh tokens failed, check ex for more details       return;     }      // use the access token to do something ...   } }); ```  This also updates the AuthState object with current access, id, and refresh tokens. If you are storing your AuthState in persistent storage, you should write the updated copy in the callback to this method.  ### Ending current session  Given you have a logged in session and you want to end it. In that case you need to get: - `AuthorizationServiceConfiguration` - valid Open Id Token that you should get after authentication - End of session URI that should be provided within you OpenId service config  First you have to build EndSessionRequest  ```java EndSessionRequest endSessionRequest =     new EndSessionRequest.Builder(authorizationServiceConfiguration)         .setIdTokenHint(idToken)         .setPostLogoutRedirectUri(endSessionRedirectUri)         .build(); ``` This request can then be dispatched using one of two approaches.  a `startActivityForResult` call using an Intent returned from the `AuthorizationService`, or by calling `performEndSessionRequest` and providing pending intent for completion and cancelation handling activities.  The startActivityForResult approach is simpler to use but may require more processing of the result:  ```java private void endSession() {   AuthorizationService authService = new AuthorizationService(this);   Intent endSessionItent = authService.getEndSessionRequestIntent(endSessionRequest);   startActivityForResult(endSessionItent, RC_END_SESSION); }  @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {   if (requestCode == RC_END_SESSION) {     EndSessionResonse resp = EndSessionResonse.fromIntent(data);     AuthorizationException ex = AuthorizationException.fromIntent(data);     // ... process the response or exception ...   } else {     // ...   } } ``` If instead you wish to directly transition to another activity on completion or cancelation, you can use `performEndSessionRequest`:  ```java AuthorizationService authService = new AuthorizationService(this);  authService.performEndSessionRequest(     endSessionRequest,     PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCompleteActivity.class), 0),     PendingIntent.getActivity(this, 0, new Intent(this, MyAuthCanceledActivity.class), 0)); ```  End session flow will also work involving browser mechanism that is described in authorization mechanism session. Handling response mechanism with transition to another activity should be as follows:   ```java public void onCreate(Bundle b) {   EndSessionResponse resp = EndSessionResponse.fromIntent(getIntent());   AuthorizationException ex = AuthorizationException.fromIntent(getIntent());   if (resp != null) {     // authorization completed   } else {     // authorization failed, check ex for more details   }   // ... } ```  ### AuthState persistence  Instances of `AuthState` keep track of the authorization and token requests and responses. This is the only object that you need to persist to retain the authorization state of the session. Typically, one would do this by storing the authorization state in SharedPreferences or some other persistent store private to the app:  ```java @NonNull public AuthState readAuthState() {   SharedPreferences authPrefs = getSharedPreferences("auth", MODE_PRIVATE);   String stateJson = authPrefs.getString("stateJson", null);   if (stateJson != null) {     return AuthState.jsonDeserialize(stateJson);   } else {     return new AuthState();   } }  public void writeAuthState(@NonNull AuthState state) {   SharedPreferences authPrefs = getSharedPreferences("auth", MODE_PRIVATE);   authPrefs.edit()       .putString("stateJson", state.jsonSerializeString())       .apply(); } ```  The demo app has an [AuthStateManager](https://github.com/openid/AppAuth-Android/blob/master/app/java/net/openid/appauthdemo/AuthStateManager.java) type which demonstrates this in more detail.  ## Advanced configuration  AppAuth provides some advanced configuration options via [AppAuthConfiguration](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AppAuthConfiguration.java) instances, which can be provided to [AuthorizationService](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationService.java) during construction.  ### Controlling which browser is used for authorization  Some applications require explicit control over which browsers can be used for authorization - for example, to require that Chrome be used for second factor authentication to work, or require that some custom browser is used for authentication in an enterprise environment.  Control over which browsers can be used can be achieved by defining a [BrowserMatcher](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/BrowserMatcher.java), and supplying this to the builder of AppAuthConfiguration. A BrowserMatcher is suppled with a [BrowserDescriptor](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/BrowserDescriptor.java) instance, and must decide whether this browser is permitted for the authorization flow.  By default, [AnyBrowserMatcher](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/AnyBrowserMatcher.java) is used.  For your convenience, utility classes to help define a browser matcher are provided, such as:  - [Browsers](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/Browsers.java):   contains a set of constants for the official package names and signatures   of Chrome, Firefox and Samsung SBrowser. - [VersionedBrowserMatcher](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/VersionedBrowserMatcher.java):   will match a browser if it has a matching package name and signature, and   a version number within a defined   [VersionRange](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/VersionRange.java). This class also provides some static instances for matching   Chrome, Firefox and Samsung SBrowser. - [BrowserAllowList](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/BrowserAllowList.java):   takes a list of BrowserMatcher instances, and will match a browser if any   of these child BrowserMatcher instances signals a match. - [BrowserDenyList](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/browser/BrowserDenyList.java):   the inverse of BrowserAllowList - takes a list of browser matcher instances,   and will match a browser if it _does not_ match any of these child   BrowserMatcher instances.  For instance, in order to restrict the authorization flow to using Chrome or SBrowser as a custom tab:  ```java AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()     .setBrowserMatcher(new BrowserAllowList(         VersionedBrowserMatcher.CHROME_CUSTOM_TAB,         VersionedBrowserMatcher.SAMSUNG_CUSTOM_TAB))     .build(); AuthorizationService authService =         new AuthorizationService(context, appAuthConfig); ```  Or, to prevent the use of a buggy version of the custom tabs in Samsung SBrowser:  ```java AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()     .setBrowserMatcher(new BrowserDenyList(         new VersionedBrowserMatcher(             Browsers.SBrowser.PACKAGE_NAME,             Browsers.SBrowser.SIGNATURE_SET,             true, // when this browser is used via a custom tab             VersionRange.atMost("5.3")         )))     .build(); AuthorizationService authService =         new AuthorizationService(context, appAuthConfig); ```  ### Customizing the connection builder for HTTP requests  It can be desirable to customize how HTTP connections are made when performing token requests, for instance to use [certificate pinning](https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning) or to add additional trusted certificate authorities for an enterprise environment. This can be achieved in AppAuth by providing a custom [ConnectionBuilder](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/connectivity/ConnectionBuilder.java) instance.  For example, to custom the SSL socket factory used, one could do the following:  ```java AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()     .setConnectionBuilder(new ConnectionBuilder() {       public HttpURLConnection openConnect(Uri uri) throws IOException {         URL url = new URL(uri.toString());         HttpURLConnection connection =             (HttpURLConnection) url.openConnection();         if (connection instanceof HttpsUrlConnection) {           HttpsURLConnection connection = (HttpsURLConnection) connection;           connection.setSSLSocketFactory(MySocketFactory.getInstance());         }       }     })     .build(); ```  ### Issues with [ID Token](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/IdToken.java#L118) validation  ID Token validation was introduced in `0.8.0` but not all authorization servers or configurations support it correctly.  - For testing environments [setSkipIssuerHttpsCheck](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AppAuthConfiguration.java#L129) can be used to bypass the fact the issuer needs to be HTTPS.  ```java AppAuthConfiguration appAuthConfig = new AppAuthConfiguration.Builder()     .setSkipIssuerHttpsCheck(true)     .build() ```  - For services that don't support nonce[s] resulting in **IdTokenException** `Nonce mismatch` just set nonce to `null` on the `AuthorizationRequest`. Please consider **raising an issue** with your Identity Provider and removing this once it is fixed.  ```java AuthorizationRequest authRequest = authRequestBuilder     .setNonce(null)     .build(); ```  ## Dynamic client registration  AppAuth supports the [OAuth2 dynamic client registration protocol](https://tools.ietf.org/html/rfc7591). In order to dynamically register a client, create a [RegistrationRequest](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/RegistrationRequest.java) and dispatch it using [performRegistrationRequest](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationService.java#L278) on your AuthorizationService instance.  The registration endpoint can either be defined directly as part of your [AuthorizationServiceConfiguration](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/AuthorizationServiceConfiguration.java), or discovered from an OpenID Connect discovery document.  ```java RegistrationRequest registrationRequest = new RegistrationRequest.Builder(     serviceConfig,     Arrays.asList(redirectUri))     .build(); ```  Requests are dispatched with the help of `AuthorizationService`. As this request is asynchronous the response is passed to a callback:  ```java service.performRegistrationRequest(     registrationRequest,     new AuthorizationService.RegistrationResponseCallback() {         @Override public void onRegistrationRequestCompleted(             @Nullable RegistrationResponse resp,             @Nullable AuthorizationException ex) {             if (resp != null) {                 // registration succeeded, store the registration response                 AuthState state = new AuthState(resp);                 //proceed to authorization...             } else {               // registration failed, check ex for more details             }          }     }); ```  ## Utilizing client secrets (DANGEROUS)  We _strongly recommend_ you avoid using static client secrets in your native applications whenever possible. Client secrets derived via a dynamic client registration are safe to use, but static client secrets can be easily extracted from your apps and allow others to impersonate your app and steal user data. If client secrets must be used by the OAuth2 provider you are integrating with, we strongly recommend performing the code exchange step on your backend, where the client secret can be kept hidden.  Having said this, in some cases using client secrets is unavoidable. In these cases, a [ClientAuthentication](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/ClientAuthentication.java) instance can be provided to AppAuth when performing a token request. This allows additional parameters (both HTTP headers and request body parameters) to be added to token requests. Two standard implementations of ClientAuthentication are provided:  - [ClientSecretBasic](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/ClientSecretBasic.java):   includes a client ID and client secret as an HTTP Basic Authorization header. - [ClientSecretPost](https://github.com/openid/AppAuth-Android/blob/master/library/java/net/openid/appauth/ClientSecretPost.java):   includes a client ID and client secret as additional request parameters.  So, in order to send a token request using HTTP basic authorization, one would write:  ```java ClientAuthentication clientAuth = new ClientSecretBasic(MY_CLIENT_SECRET); TokenRequest req = ...; authService.performTokenRequest(req, clientAuth, callback); ```  This can also be done when using `performActionWithFreshTokens` on AuthState:  ```java ClientAuthentication clientAuth = new ClientSecretPost(MY_CLIENT_SECRET); authState.performActionWithFreshTokens(     authService,     clientAuth,     action); ```  ## Modifying or contributing to AppAuth  This project requires the Android SDK for API level 25 (Nougat) to build, though the produced binaries only require API level 16 (Jellybean) to be used. We recommend that you fork and/or clone this repository to make modifications; downloading the source has been known to cause some developers problems.  For contributors, see the additional instructions in [CONTRIBUTING.md](https://github.com/openid/AppAuth-Android/blob/master/CONTRIBUTING.md).  ### Building from the Command line  AppAuth for Android uses Gradle as its build system. In order to build the library and app binaries, run `./gradlew assemble`. The library AAR files are output to `library/build/outputs/aar`, while the demo app is output to `app/build/outputs/apk`. In order to run the tests and code analysis, run `./gradlew check`.  ### Building from Android Studio  In AndroidStudio, File -> New -> Import project. Select the root folder (the one with the `build.gradle` file). |
| Maor-Oz/Medical-Segmentation-Decathlon-U-net-CNN-with-Generalized-Dice-Coefficient â€” https://github.com/Maor-Oz/Medical-Segmentation-Decathlon-U-net-CNN-with-Generalized-Dice-Coefficient | 23 | Python | UNKNOWN | verify | 2025-12-03T15:20:04Z | With recent advances in machine learning, semantic segmentation algorithms are becoming increasingly general-purpose and translatable to unseen tasks. Many key algorithmic advances in the field of medical imaging are commonly validated on a small number of tasks, limiting our understanding of the generalizability of the proposed contributions. A model which works out-of-the-box on many tasks, in the spirit of AutoML (Automated Machine Learning), would have a tremendous impact on healthcare. The field of medical imaging is also missing a fully open source and comprehensive benchmark for general-purpose algorithmic validation and testing covering a large span of challenges, such as: small data, unbalanced labels, large-ranging object scales, multi-class labels, and multimodal imaging, etc. To address these problems, in this project, as part of the MSD challenge, we propose a generic machine learning algorithm which we applied on two organs: liver and tumors, spleen. We propose an unsupervised generic model by implementing U-net CNN architecture with Generalized Dice Coefficient as loss function and also as a metric. The MSD dataset consists of dozens of medical examinations in 3D (per organ), weâ€™ll transform the 3-dimensional data into 2-d cuts as an input of our U-net. Experimental results show that our generic model based on U-net and Generalized Dice Coefficient algorithm leads to high segmentation accuracy for each organ (liver and tumors, spleen), separately, without human interaction, with a relatively short run time compared to traditional segmentation methods. |
| ramincsy/Best-Coin-Address-Validator- â€” https://github.com/ramincsy/Best-Coin-Address-Validator- | 13 | C# | UNKNOWN | verify | 2025-12-17T08:03:17Z | Best-Coin-Address-Validator is an open-source console app in C# for validating digital currency addresses. Its secure algorithms ensure valid addresses for Bitcoin, Ethereum, Litecoin, and more. With a simple UI, it's easy to integrate into other apps, giving users confidence in trustworthy addresses. It's cross-platform and viewable on GitHub. |

