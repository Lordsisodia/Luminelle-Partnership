# OSS Shortlist (Top 20, vibe-coding oriented)

This shortlist is optimized for:
- fast integration / MVP acceleration
- React/TypeScript-heavy stacks
- license safety (prefer permissive)

Legend:
- ‚úÖ permissive: MIT/Apache/BSD/etc.
- ‚ö†Ô∏è unknown: license not asserted in API metadata (verify manually)
- üß® copyleft: GPL/AGPL/LGPL (flag for review)

## 1) authzed/spicedb

- Repo: https://github.com/authzed/spicedb
- Stars: 6310
- License: ‚úÖ Apache-2.0
- Language: Go
- Updated: 2025-12-29T23:57:22Z
- Description: Open Source, Google Zanzibar-inspired database for scalably storing and querying fine-grained authorization data

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 2) AthenZ/athenz

- Repo: https://github.com/AthenZ/athenz
- Stars: 978
- License: ‚úÖ Apache-2.0
- Language: Java
- Updated: 2025-12-27T14:44:44Z
- Description: Open source platform for X.509 certificate based service authentication and fine grained access control in dynamic infrastructures. Athenz supports provisioning and configuration (centralized authorization) use cases as well as serving/runtime (decentralized authorization) use cases.

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 3) retracedhq/retraced

- Repo: https://github.com/retracedhq/retraced
- Stars: 426
- License: ‚úÖ Apache-2.0
- Language: TypeScript
- Updated: 2025-12-26T13:02:23Z
- Description: üî• A fully open source audit logs service and embeddable UI easily deployed to your own Kubernetes cluster. Brought to you by replicated.com and boxyhq.com  üöÄ

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 4) raystack/frontier

- Repo: https://github.com/raystack/frontier
- Stars: 314
- License: ‚úÖ Apache-2.0
- Language: Go
- Updated: 2025-12-29T03:52:36Z
- Description: Frontier is an all-in-one user management platform that provides identity, access and billing management to help organizations secure their systems and data. (Open source alternative to Clerk, WorkOS)

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 5) aipotheosis-labs/gate22

- Repo: https://github.com/aipotheosis-labs/gate22
- Stars: 150
- License: ‚úÖ Apache-2.0
- Language: TypeScript
- Updated: 2025-12-18T05:59:34Z
- Description: Open-source MCP gateway and control plane for teams to govern which tools agents can use, what they can do, and how it‚Äôs audited‚Äîacross agentic IDEs like Cursor, or other agents and AI tools.

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 6) OCA/rma

- Repo: https://github.com/OCA/rma
- Stars: 91
- License: üß® AGPL-3.0
- Language: Python
- Updated: 2025-12-28T01:04:07Z
- Description: Odoo for Return Merchandise Authorization (RMA)

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 7) Mdshobu/Liberty-House-Club-Whitepaper

- Repo: https://github.com/Mdshobu/Liberty-House-Club-Whitepaper
- Stars: 24
- License: ‚úÖ Apache-2.0
- Language: N/A
- Updated: 2025-12-15T06:02:43Z
- Description: # Liberty House Club **A Parallel Binance Chain to Enable Smart Contracts**  _NOTE: This document is under development. Please check regularly for updates!_  ## Table of Contents - [Motivation](#motivation) - [Design Principles](#design-principles) - [Consensus and Validator Quorum](#consensus-and-validator-quorum)   * [Proof of Staked Authority](#proof-of-staked-authority)   * [Validator Quorum](#validator-quorum)   * [Security and Finality](#security-and-finality)   * [Reward](#reward) - [Token Economy](#token-economy)   * [Native Token](#native-token)   * [Other Tokens](#other-tokens) - [Cross-Chain Transfer and Communication](#cross-chain-transfer-and-communication)   * [Cross-Chain Transfer](#cross-chain-transfer)   * [BC to BSC Architecture](#bc-to-bsc-architecture)   * [BSC to BC Architecture](#bsc-to-bc-architecture)   * [Timeout and Error Handling](#timeout-and-error-handling)   * [Cross-Chain User Experience](#cross-chain-user-experience)   * [Cross-Chain Contract Event](#cross-chain-contract-event) - [Staking and Governance](#staking-and-governance)   * [Staking on BC](#staking-on-bc)   * [Rewarding](#rewarding)   * [Slashing](#slashing) - [Relayers](#relayers)   * [BSC Relayers](#bsc-relayers)   * [Oracle Relayers](#oracle-relayers) - [Outlook](#outlook) # Motivation  After its mainnet community [launch](https://www.binance.com/en/blog/327334696200323072/Binance-DEX-Launches-on-Binance-Chain-Invites-Further-Community-Development) in April 2019, [Binance Chain](https://www.binance.org) has exhibited its high speed and large throughput design. Binance Chain‚Äôs primary focus, its native [decentralized application](https://en.wikipedia.org/wiki/Decentralized_application) (‚ÄúdApp‚Äù) [Binance DEX](https://www.binance.org/trade), has demonstrated its low-latency matching with large capacity headroom by handling millions of trading volume in a short time.  Flexibility and usability are often in an inverse relationship with performance. The concentration on providing a convenient digital asset issuing and trading venue also brings limitations. Binance Chain's most requested feature is the programmable extendibility, or simply the [Smart Contract](https://en.wikipedia.org/wiki/Smart_contract) and Virtual Machine functions. Digital asset issuers and owners struggle to add new decentralized features for their assets or introduce any sort of community governance and activities.  Despite this high demand for adding the Smart Contract feature onto Binance Chain, it is a hard decision to make. The execution of a Smart Contract may slow down the exchange function and add non-deterministic factors to trading. If that compromise could be tolerated, it might be a straightforward idea to introduce a new Virtual Machine specification based on [Tendermint](https://tendermint.com/core/), based on the current underlying consensus protocol and major [RPC](https://docs.binance.org/api-reference/node-rpc.html) implementation of Binance Chain. But all these will increase the learning requirements for all existing dApp communities, and will not be very welcomed.  We propose a parallel blockchain of the current Binance Chain to retain the high performance of the native DEX blockchain and to support a friendly Smart Contract function at the same time.  # Design Principles  After the creation of the parallel blockchain into the Binance Chain ecosystem, two blockchains will run side by side to provide different services. The new parallel chain will be called ‚Äú**Binance Smart Chain**‚Äù (short as ‚Äú**BSC**‚Äù for the below sections), while the existing mainnet remains named ‚Äú**Binance Chain**‚Äù (short as ‚Äú**BC**‚Äù for the below sections).  Here are the design principles of **BSC**:  1. **Standalone Blockchain**: technically, BSC is a standalone blockchain, instead of a layer-2 solution. Most BSC fundamental  technical and business functions should be self-contained so that it can     run well even if the BC stopped for a short period. 2. **Ethereum  Compatibility**: The first practical and widely-used Smart Contract platform is Ethereum. To take advantage of the relatively mature applications and community, BSC chooses to be compatible with the existing Ethereum mainnet. This means most of the **dApps**, ecosystem components, and toolings will work with BSC and require zero or minimum changes; BSC node will require similar (or a bit higher) hardware specification and skills to run and operate. The implementation should leave room for BSC to catch up with further Ethereum upgrades. 3. **Staking Involved  Consensus and Governance**: Staking-based consensus is more environmentally friendly and leaves more flexible option to the community governance. Expectedly, this consensus should enable better network performance over [proof-of-work](https://en.wikipedia.org/wiki/Proof_of_work) blockchain system, i.e., faster blocking time and higher transaction capacity. 4. **Native Cross-Chain Communication**: both BC and BSC will be implemented with native support for cross-chain communication among the two blockchains. The communication protocol should be bi-directional, decentralized, and trustless. It will concentrate on moving digital assets between BC and BSC, i.e., [BEP2](https://github.com/binance-chain/BEPs/blob/master/BEP2.md) tokens, and eventually, other BEP tokens introduced later. The protocol should care for the minimum of other items stored in the state of the blockchains, with only a few exceptions.  # Consensus and Validator Quorum  Based on the above design principles, the consensus protocol of BSC is to fulfill the following goals:  1. Blocking time should be shorter than Ethereum network, e.g. 5 seconds or even shorter. 2. It requires limited time to confirm the finality of transactions, e.g. around 1-min level or shorter. 3. There is no inflation of native token: BNB, the block reward is collected from transaction fees, and it will be paid in BNB. 4. It is compatible with Ethereum system as much as possible. 5. It allows modern [proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) blockchain network governance.  ## Proof of Staked Authority  Although Proof-of-Work (PoW) has been recognized as a practical mechanism to implement a decentralized network, it is not friendly to the environment and also requires a large size of participants to maintain the security.  Ethereum and some other blockchain networks, such as [MATIC Bor](https://github.com/maticnetwork/bor), [TOMOChain](https://tomochain.com/), [GoChain](https://gochain.io/), [xDAI](https://xdai.io/), do use [Proof-of-Authority(PoA)](https://en.wikipedia.org/wiki/Proof_of_authority) or its variants in different scenarios, including both testnet and mainnet. PoA provides some defense to 51% attack, with improved efficiency and tolerance to certain levels of Byzantine players (malicious or hacked). It serves as an easy choice to pick as the fundamentals.  Meanwhile, the PoA protocol is most criticized for being not as decentralized as PoW, as the validators, i.e. the nodes that take turns to produce blocks, have all the authorities and are prone to corruption and security attacks. Other blockchains, such as EOS and Lisk both, introduce different types of [Delegated Proof of Stake (DPoS)](https://en.bitcoinwiki.org/wiki/DPoS) to allow the token holders to vote and elect the validator set. It increases the decentralization and favors community governance.  BSC here proposes to combine DPoS and PoA for consensus, so that: 1. Blocks are produced by a limited set of validators 2. Validators take turns to produce blocks in a PoA manner, similar to [Ethereum‚Äôs Clique](https://eips.ethereum.org/EIPS/eip-225) consensus design 3. Validator set are elected in and out based on a staking based governance  ## Validator Quorum  In the genesis stage, a few trusted nodes will run as the initial Validator Set. After the blocking starts, anyone can compete to join as candidates to elect as a validator. The staking status decides the top 21 most staked nodes to be the next validator set, and such an election will repeat every 24 hours.  **BNB** is the token used to stake for BSC.  In order to remain as compatible as Ethereum and upgradeable to future consensus protocols to be developed, BSC chooses to rely on the **BC** for staking management (Please refer to the below ‚Äú[Staking and Governance](#staking-and-governance)‚Äù section). There is a **dedicated staking module for BSC on BC**. It will accept BSC staking from BNB holders and calculate the highest staked node set. Upon every UTC midnight, BC will issue a verifiable `ValidatorSetUpdate` cross-chain message to notify BSC to update its validator set.  While producing further blocks, the existing BSC validators check whether there is a `ValidatorSetUpdate` message relayed onto BSC periodically. If there is, they will update the validator set after an **epoch period**, i.e. a predefined number of blocking time. For example, if BSC produces a block every 5 seconds, and the epoch period is 240 blocks, then the current validator set will check and update the validator set for the next epoch in 1200 seconds (20 minutes).  ## Security and Finality  Given there are more than ¬Ω\*N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the ‚Äú[Clone Attack](https://arxiv.org/pdf/1902.10244.pdf)‚Äù. To secure as much as BC, BSC users are encouraged to wait until receiving blocks sealed by more than ‚Öî\*N+1 different validators. In that way, the BSC can be trusted at a similar security level to BC and can tolerate less than ‚Öì\*N Byzantine validators.  With 21 validators, if the block time is 5 seconds, the ‚Öî\*N+1 different validator seals will need a time period of (‚Öî\*21+1)*5 = 75 seconds. Any critical applications for BSC may have to wait for ‚Öî\*N+1 to ensure a relatively secure finality. However, besides such arrangement, BSC does introduce **Slashing** logic to penalize Byzantine validators for **double signing** or **inavailability**, which will be covered in the ‚ÄúStaking and Governance‚Äù section later. This Slashing logic will expose the malicious validators in a very short time and make the ‚ÄúClone Attack‚Äù very hard or extremely non-beneficial to execute. With this enhancement, ¬Ω\*N+1 or even fewer blocks are enough as confirmation for most transactions.  ## Reward  All the BSC validators in the current validator set will be rewarded with transaction **fees in BNB**. As BNB is not an inflationary token, there will be no mining rewards as what Bitcoin and Ethereum network generate, and the gas fee is the major reward for validators. As BNB is also utility tokens with other use cases, delegators and validators will still enjoy other benefits of holding BNB.  The reward for validators is the fees collected from transactions in each block. Validators can decide how much to give back to the delegators who stake their BNB to them, in order to attract more staking. Every validator will take turns to produce the blocks in the same probability (if they stick to 100% liveness), thus, in the long run, all the stable validators may get a similar size of the reward. Meanwhile, the stakes on each validator may be different, so this brings a counter-intuitive situation that more users trust and delegate to one validator, they potentially get less reward. So rational delegators will tend to delegate to the one with fewer stakes as long as the validator is still trustful (insecure validator may bring slashable risk). In the end, the stakes on all the validators will have less variation. This will actually prevent the stake concentration and ‚Äúwinner wins forever‚Äù problem seen on some other networks.  Some parts of the gas fee will also be rewarded to relayers for Cross-Chain communication. Please refer to the ‚Äú[Relayers](#relayers)‚Äù section below.  # Token Economy  BC and BSC share the same token universe for BNB and BEP2 tokens. This defines:  1. The same token can circulate on both networks, and flow between them bi-directionally     via a cross-chain communication mechanism. 2. The total circulation of the same token should be managed across the two networks, i.e. the total effective supply of a token should be the sum of the     token‚Äôs total effective supply on both BSC and BC. 3. The tokens can be initially created on BSC in a similar format as ERC20 token standard, or on BC as a BEP2, then created on the other. There are native ways on both networks to link the two and secure the total supply of the token.  ## Native Token  BNB will run on BSC in the same way as ETH runs on Ethereum so that it remains as ‚Äúnative token‚Äù for both BSC and BC. This means, in addition to BNB is used to pay most of the fees on Binance Chain and Binance DEX, BNB will be also used to:  1. pay ‚Äúfees‚Äú to deploy smart contracts on BSC 2. stake on selected BSC validators, and get corresponding rewards 3. perform cross-chain operations, such as transfer token assets across BC and BSC  ### Seed Fund  Certain amounts of BNB will be burnt on BC and minted on BSC during its genesis stage. This amount is called ‚ÄúSeed Fund‚Äù to circulate on BSC after the first block, which will be dispatched to the initial BC-to-BSC Relayer(described in later sections) and initial validator set introduced at genesis. These BNBs are used to pay transaction fees in the early stage to transfer more BNB from BC onto BSC via the cross-chain mechanism.  The BNB cross-chain transfer is discussed in a later section, but for BC to BSC transfer, it is generally to lock BNB on BC from the source address of the transfer to a system-controlled address and unlock the corresponding amount from special contract to the target address of the transfer on BSC, or reversely, when transferring from BSC to BC, it is to lock BNB from the source address on BSC into a special contract and release locked amount on BC from the system address to the target address. The logic is related to native code on BC and a series of smart contracts on BSC.  ## Other Tokens  BC supports BEP2 tokens and upcoming [BEP8 tokens](https://github.com/binance-chain/BEPs/pull/69), which are native assets transferrable and tradable (if listed) via fast transactions and sub-second finality. Meanwhile, as BSC is Ethereum compatible, it is natural to support ERC20 tokens on BSC, which here is called ‚Äú**BEP2E**‚Äù (with the real name to be introduced by the future BEPs,it potentially covers BEP8 as well). BEP2E may be ‚ÄúEnhanced‚Äù by adding a few more methods to expose more information, such as token denomination, decimal precision definition and the owner address who can decide the Token Binding across the chains. BSC and BC work together to ensure that one token can circulate in both formats with confirmed total supply and be used in different use cases.  ### Token Binding  BEP2 tokens will be extended to host a new attribute to associate the token with a BSC BEP2E  token contract, called ‚Äú**Binder**‚Äù, and this process of association is called ‚Äú**Token Binding**‚Äù.  Token Binding can happen at any time after BEP2 and BEP2E are ready. The token owners of either BEP2 or BEP2E don‚Äôt need to bother about the Binding, until before they really want to use the tokens on different scenarios. Issuers can either create BEP2 first or BEP2E first, and they can be bound at a later time. Of course, it is encouraged for all the issuers of BEP2 and BEP2E to set the Binding up early after the issuance.  A typical procedure to bind the BEP2 and BEP2E will be like the below:  1. Ensure both the BEP2 token and the BEP2E token both exist on each blockchain, with the same total supply. BEP2E should have 3 more methods than typical ERC20 token standard:     *  symbol(): get token symbol     *  decimals(): get the number of the token decimal digits     *  owner(): get **BEP2E contract owner‚Äôs address.** This value should be initialized in the BEP2E contract constructor so that the further binding action can verify whether the action is from the BEP2E owner.  2. Decide the initial circulation on both blockchains. Suppose the total supply is *S*, and the expected initial circulating supply on BC is *K*, then the owner should lock S-K tokens to a system controlled address on BC.  3. Equivalently, *K* tokens is locked in the special contract on BSC, which handles major binding functions and is named as **TokenHub**. The issuer of the BEP2E token should lock the *K* amount of that token into TokenHub, resulting in *S-K* tokens to circulate on BSC. Thus the total circulation across 2 blockchains remains as *S*.  4. The issuer of BEP2 token sends the bind transaction on BC. Once the transaction is executed successfully after proper verification:     * It transfers *S-K* tokens to a system-controlled address on BC.     * A cross-chain bind request package will be created, waiting for Relayers to relay.  5. BSC Relayers will relay the cross-chain bind request package into **TokenHub** on BSC, and the corresponding request and information will be stored into the contract.  6. The contract owner and only the owner can run a special method of TokenHub contract, `ApproveBind`, to verify the binding request to mark it as a success. It will confirm:     * the token has not been bound;     * the binding is for the proper symbol, with proper total supply and decimal information;     * the proper lock are done on both networks;  10. Once the `ApproveBind` method has succeeded, TokenHub will mark the two tokens are bounded and share the same circulation on BSC, and the status will be propagated back to BC. After this final confirmation, the BEP2E contract address and decimals will be written onto the BEP2 token as a new attribute on BC, and the tokens can be transferred across the two blockchains bidirectionally. If the ApproveBind fails, the  failure event will also be propagated back to BC to release the locked tokens, and the above steps can be re-tried later.  # Cross-Chain Transfer and Communication Cross-chain communication is the key foundation to allow the community to take advantage of the dual chain structure:  * users are free to create any tokenization, financial products, and digital assets on BSC or BC as they wish * the items on BSC can be manually and programmingly traded and circulated in a stable, high throughput, lighting fast and friendly environment of BC * users can operate these in one UI and tooling ecosystem.  ## Cross-Chain Transfer  The cross-chain transfer is the key communication between the two blockchains. Essentially the logic is:  1. the `transfer-out` blockchain will lock the amount from source owner addresses into a system controlled address/contracts; 2. the `transfer-in` blockchain will unlock the amount from the system controlled address/contracts and send it to target addresses.  The cross-chain transfer package message should allow the BSC Relayers and BC **Oracle Relayers** to verify:  1. Enough amount of token assets are removed from the source address and locked into a system controlled addresses/contracts on the source blockchain. And this can be confirmed on the target blockchain. 2. Proper amounts of token assets are released from a system controlled addresses/contracts and allocated into target addresses on the target blockchain. If this fails, it can be confirmed on source blockchain, so that the locked token can be released back (may deduct fees). 3. The sum of the total circulation of the token assets across the 2 blockchains are not changed after this transfer action completes, no matter if the transfer succeeds or not.  ![cross-chain](./assets/cross-chain.png)  The architecture of cross-chain communication is as in the above diagram. To accommodate the 2 heteroid systems, communication handling is different in each direction.  ## BC to BSC Architecture  BC is a Tendermint-based, instant finality blockchain. Validators with at least ‚Öî\*N+1 of the total voting power will co-sign each block on the chain. So that it is practical to verify the block transactions and even the state value via **Block Header** and **Merkle Proof** verification. This has been researched and implemented as ‚Äú**Light-Client Protocol**‚Äù, which are intensively discussed in [the Ethereum](https://github.com/ethereum/wiki/wiki/Light-client-protocol) community, studied and implemented for [Cosmos inter-chain communication](https://github.com/cosmos/ics/blob/a4173c91560567bdb7cc9abee8e61256fc3725e9/spec/ics-007-tendermint-client/README.md).  BC-to-BSC communication will be verified in an ‚Äú**on-chain light client**‚Äù implemented via BSC **Smart Contracts** (some of them may be **‚Äúpre-compiled‚Äù**). After some transactions and state change happen on BC, if a transaction is defined to trigger cross-chain communication,the Cross-chain ‚Äú**package**‚Äù message will be created and **BSC Relayers** will pass and submit them onto BSC as data into the "build-in system contracts". The build-in system contracts will verify the package and execute the transactions if it passes the verification. The verification will be guaranteed with the below design:  1. BC blocking status will be synced to the light client contracts on BSC from time to time, via     block header and pre-commits, for the below information:     * block and app hash of BC that are signed by validators     * current validatorset, and validator set update  2. the key-value from the blockchain state will be verified based on the Merkle     Proof and information from above #1.  After confirming the key-value is accurate and trustful, the build-in system contracts will execute the actions corresponding to the cross-chain packages. Some examples of such packages that can be created for BC-to-BSC are:  1. Bind: bind the BEP2 tokens and BEP2E 2. Transfer: transfer tokens after binding, this means the circulation will decrease (be locked)     from BC and appear in the target address balance on BSC 3. Error Handling: to handle any timeout/failure event for BSC-to-BC communication 4. Validatorset update of BSC  To ensure no duplication, proper message sequence and timely timeout, there is a ‚ÄúChannel‚Äù concept introduced on BC to manage any types of the communication.  For relayers, please also refer to the below ‚ÄúRelayers‚Äù section.  ## BSC to BC Architecture  BSC uses Proof of Staked Authority consensus protocol, which has a chance to fork and requires confirmation of more blocks. One block only has the signature of one validator, so that it is not easy to rely on one block to verify data from BSC.  To take full advantage of validator quorum of BC, an idea similar to many [Bridge ](https://github.com/poanetwork/poa-bridge)or Oracle blockchains is adopted:  1. The cross-chain communication requests from BSC will be submitted and executed onto BSC as transactions. The execution of the transanction wil emit `Events`, and such events can be observed and packaged in certain ‚Äú**Oracle**‚Äù onto BC. Instead of Block Headers, Hash and Merkle Proof, this type of ‚ÄúOracle‚Äù package directly contains the cross-chain information for actions, such as sender, receiver and amount for transfer. 2. To ensure the security of the Oracle, the validators of BC will form anothe quorum of ‚Äú**Oracle Relayers**‚Äù. Each validator of the BC should run a **dedicated process** as the Oracle Relayer. These Oracle Relayers will submit and  vote for the cross-chain communication package, like Oracle, onto BC,  using the same validator keys. Any package signed by more than ‚Öî\*N+1 Oracle Relayers‚Äô voting power is as secure as any block signed by ‚Öî\*N+1 of     the same quorum of validators‚Äô voting power.  By using the same validator quorum, it saves the light client code on BC and continuous block updates onto BC. Such Oracles also have Oracle IDs and types, to ensure sequencing and proper error handling.  ## Timeout and Error Handling  There are scenarios that the cross-chain communication fails. For example, the relayed package cannot be executed on BSC due to some coding bug in the contracts. **Timeout and error handling logics are** used in such scenarios.  For the recognizable user and system errors or any expected exceptions, the two networks should heal themselves. For example, when BC to BSC transfer fails, BSC will issue a failure event and Oracle Relayers will execute a refund on BC; when BSC to BC transfer fails, BC will issue a refund package for Relayer to relay in order to unlock the fund.  However, unexpected error or exception may still happen on any step of the cross-chain communication. In such a case, the Relayers and Oracle Relayers will discover that the corresponding cross-chain channel is stuck in a particular sequence. After a Timeout period, the Relayers and Oracle Relayers can request a ‚ÄúSkipSequence‚Äù transaction, the stuck sequence will be marked as ‚ÄúUnexecutable‚Äù. A corresponding alerts will be raised, and the community has to discuss how to handle this scenario, e.g. payback via the sponsor of the validators, or event clear the fund during next network upgrade.  ## Cross-Chain User Experience  Ideally, users expect to use two parallel chains in the same way as they use one single chain. It requires more aggregated transaction types to be added onto the cross-chain communication to enable this, which will add great complexity, tight coupling, and maintenance burden. Here BC and BSC only implement the basic operations to enable the value flow in the initial launch and leave most of the user experience work to client side UI, such as wallets. E.g. a great wallet may allow users to sell a token directly from BSC onto BC‚Äôs DEX order book, in a secure way.  ## Cross-Chain Contract Event  Cross-Chain Contract Event (CCCE) is designed to allow a smart contract to trigger cross-chain transactions, directly through the contract code. This becomes possible based on:  1. Standard  system contracts can be provided to serve operations callable by general     smart contracts; 2. Standard  events can be emitted by the standard contracts; 3. Oracle Relayers can capture the standard events, and trigger the corresponding cross-chain operations; 4. Dedicated, code-managed address (account) can be created on BC and accessed by the     contracts on the BSC, here it is named as **‚ÄúContract Address on BC‚Äù (CAoB)**.  Several standard operations are implemented:  1. BSC to BC transfer: this is implemented in the same way as normal BSC to BC transfer, by only triggered via standard contract. The fund can be transferred to any addresses on BC, including the corresponding CAoB of  the transfer originating contract. 2. Transfer on BC: this is implemented as a special cross-chain transfer, while the  real transfer is from **CAoB** to any other address (even another CAoB). 3. BC to BSC transfer: this is implemented as two-pass cross-chain communication. The     first is triggered by the BSC contract and propagated onto BC, and then in the second pass, BC will start a normal BC to BSC cross-chain transfer, from **CAoB** to contract address on BSC. A special note should be paid on that the BSC contract only increases balance upon any transfer coming in on the second pass, and the error handling in the second pass is the same as the normal BC to BSC transfer. 4. IOC  (Immediate-Or-Cancel) Trade Out: the primary goal of transferring assets to BC is to trade. This event will instruct to trade a certain amount of an asset in CAoB into another asset as much as possible and transfer out     all the results, i.e. the left the source and the traded target tokens of     the trade, back to BSC. BC will handle such relayed events by sending an     ‚ÄúImmediate-Or-Cancel‚Äù, i.e. IOC order onto the trading pairs, once the next matching finishes, the result will be relayed back to BSC, which can be in either one or two assets. 5. Auction Trade Out: Such event will instruct BC to send an auction order to trade a     certain amount of an asset in **CAoB** into another asset as much as possible and transfer out all the results back to BSC at the end of the auction. Auction function is upcoming on BC.  There are some details for the Trade Out:  1. both can have a limit price (absolute or relative) for the trade; 2. the end result will be written as cross-chain packages to relay back to BSC; 3. cross-chain communication fees may be charged from the asset transferred back to BSC; 4. BSC contract maintains a mirror of the balance and outstanding orders on CAoB. No     matter what error happens during the Trade Out, the final status will be  propagated back to the originating contract and clear its internal state.  With the above features, it simply adds the cross-chain transfer and exchange functions with high liquidity onto all the smart contracts on BSC. It will greatly add the application scenarios on Smart Contract and dApps, and make 1 chain +1 chain > 2 chains.  # Staking and Governance  Proof of Staked Authority brings in decentralization and community involvement. Its core logic can be summarized as the below. You may see similar ideas from other networks, especially Cosmos and EOS.  1. Token holders, including the validators, can put their tokens ‚Äú**bonded**‚Äù into the stake. Token holders can **delegate** their tokens onto any validator or validator candidate, to expect it can become an actual validator, and later they can choose a different validator or candidate to **re-delegate** their tokens<sup>1</sup>. 2. All validator candidates will be ranked by the number of bonded tokens on them, and the top ones will become the real validators. 3. Validators can share (part of) their blocking reward with their delegators. 4. Validators can suffer from ‚Äú**Slashing**‚Äù, a punishment for their bad behaviors, such as double sign and/or instability. 5. There is an ‚Äú**unbonding period**‚Äù for validators and delegators so that the system makes sure the tokens remain bonded when bad behaviors are caught, the responsible will get slashed during this period.  ## Staking on BC  Ideally, such staking and reward logic should be built into the blockchain, and automatically executed as the blocking happens. Cosmos Hub, who shares the same Tendermint consensus and libraries with Binance Chain, works in this way.  BC has been preparing to enable staking logic since the design days. On the other side, as BSC wants to remain compatible with Ethereum as much as possible, it is a great challenge and efforts to implement such logic on it. This is especially true when Ethereum itself may move into a different Proof of Stake consensus protocol in a short (or longer) time. In order to keep the compatibility and reuse the good foundation of BC, the staking logic of BSC is implemented on BC:  1. The staking token is BNB, as it is a native token on both blockchains anyway 2. The staking, i.e. token bond and delegation actions and records for BSC, happens on BC. 3. The BSC validator set is determined by its staking and delegation logic, via a  staking module built on BC for BSC, and propagated every day UTC 00:00 from BC to BSC via Cross-Chain communication. 4. The reward distribution happens on BC around every day UTC 00:00.  ## Rewarding  Both the validator update and reward distribution happen every day around UTC 00:00. This is to save the cost of frequent staking updates and block reward distribution. This cost can be significant, as the blocking reward is collected on BSC and distributed on BC to BSC validators and delegators. (Please note BC blocking fees will remain rewarding to BC validators only.)   A deliberate delay is introduced here to make sure the distribution is fair:  1. The blocking reward will not be sent to validator right away, instead, they will be distributed and accumulated on a contract; 2. Upon receiving the validator set update into BSC, it will trigger a few cross-chain transfers to transfer the reward to custody addresses on the corresponding validators. The custody addresses are owned by the system so that the reward cannot be spent until the promised distribution to delegators happens. 3. In order to make the synchronization simpler and allocate time to accommodate slashing, the reward for N day will be only distributed in N+2 days. After the delegators get the reward, the left will be transferred to validators‚Äô own reward addresses.  ## Slashing  Slashing is part of the on-chain governance, to ensure the malicious or negative behaviors are punished. BSC slash can be submitted by anyone. The transaction submission requires **slash evidence** and cost fees but also brings a larger reward when it is successful.  So far there are two slashable cases.  ### Double Sign  It is quite a serious error and very likely deliberate offense when a validator signs more than one block with the same height and parent block. The reference protocol implementation should already have logic to prevent this, so only the malicious code can trigger this. When Double Sign happens, the validator should be removed from the Validator **Set** right away.  Anyone can submit a slash request on BC with the evidence of Double Sign of BSC, which should contain the 2 block headers with the same height and parent block, sealed by the offending validator. Upon receiving the evidence, if the BC verifies it to be valid:  1. The validator will be removed from validator set by an instance BSC validator set update Cross-Chain update; 2. A predefined amount of BNB would be slashed from the **self-delegated** BNB of the validator; Both validator and its delegators will not receive the staking rewards.  3. Part of the slashed BNB will allocate to the submitter‚Äôs address, which is a reward and larger than the cost of submitting slash request transaction 4. The rest of the slashed BNB will allocate to the other validators‚Äô custody addresses, and distributed to all delegators in the same way as blocking reward.  ### Inavailability  The liveness of BSC relies on everyone in the Proof of Staked Authority validator set can produce blocks timely when it is their turn. Validators can miss their turn due to any reason, especially problems in their hardware, software, configuration or network. This instability of the operation will hurt the performance and introduce more indeterministic into the system.  There can be an internal smart contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. In such a way, the poorly-operating validator should be gradually voted out of the validator set as their delegators will receive less or none reward. If the metrics remain above another higher level of threshold, the validator will be dropped from the rotation, and this will be propagated back to BC, then a predefined amount of BNB would be slashed from the **self-delegated** BNB of the validator. Both validators and delegators will not receive their staking rewards.   ###  Governance Parameters  There are many system parameters to control the behavior of the BSC, e.g. slash amount, cross-chain transfer fees. All these parameters will be determined by BSC Validator Set together through a proposal-vote process based on their staking. Such the process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via a cross-chain communication.  # Relayers  Relayers are responsible to submit Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created.  ## BSC Relayers  Relayers for BC to BSC communication referred to as ‚Äú**BSC Relayers**‚Äù, or just simply ‚ÄúRelayers‚Äù. Relayer is a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto BSC and deposit a certain refundable amount of BNB. Only relaying requests from the registered Relayers will be accepted by BSC.   The package they relay will be verified by the on-chain light client on BSC. The successful relay needs to pass enough verification and costs gas fees on BSC, and thus there should be incentive reward to encourage the community to run Relayers.  ### Incentives  There are two major communication types:  1. Users triggered Operations, such as `token bind` or `cross chain transfer`. Users must pay additional fee to as relayer reward. The reward will be shared with the relayers who sync the referenced blockchain headers. Besides, the reward won't be paid the relayers' accounts directly. A reward distribution mechanism will be brought in to avoid monopolization. 2. System Synchronization, such as delivering `refund package`(caused by failures of most oracle relayers), special blockchain header synchronization(header contains BC validatorset update), BSC staking package. System reward contract will pay reward to relayers' accounts directly.  If some Relayers have faster networks and better hardware, they can monopolize all the package relaying and leave no reward to others. Thus fewer participants will join for relaying, which encourages centralization and harms the efficiency and security of the network. Ideally, due to the decentralization and dynamic re-election of BSC validators, one Relayer can hardly be always the first to relay every message. But in order to avoid the monopolization further, the rewarding economy is also specially designed to minimize such chance:  1. The reward for Relayers will be only distributed in batches, and one batch will cover a number of successful relayed packages. 2. The reward a Relayer can get from a batch distribution is not linearly in proportion to their number of successful relayed packages. Instead, except the first a few relays, the more a Relayer relays during a batch period, the less reward it will collect.  ## Oracle Relayers  Relayers for BSC to BC communication are using the ‚ÄúOracle‚Äù model, and so-called ‚Äú**Oracle Relayers**‚Äù. Each of the validators must, and only the ones of the validator set, run Oracle Relayers. Each Oracle Relayer watches the blockchain state change. Once it catches Cross-Chain Communication Packages, it will submit to vote for the requests. After Oracle Relayers from ‚Öî of the voting power of BC validators vote for the changes, the cross-chain actions will be performed.  Oracle Replayers should wait for enough blocks to confirm the finality on BSC before submitting and voting for the cross-chain communication packages onto BC.  The cross-chain fees will be distributed to BC validators together with the normal BC blocking rewards.  Such oracle type relaying depends on all the validators to support. As all the votes for the cross-chain communication packages are recorded on the blockchain, it is not hard to have a metric system to assess the performance of the Oracle Relayers. The poorest performer may have their rewards clawed back via another Slashing logic introduced in the future.  # Outlook  It is hard to conclude for Binance Chain, as it has never stopped evolving. The dual-chain strategy is to open the gate for users to take advantage of the fast transferring and trading on one side, and flexible and extendable programming on the other side, but it will be one stop along the development of Binance Chain. Here below are the topics to look into so as to facilitate the community better for more usability and extensibility:  1. Add different digital asset model for different business use cases 2. Enable more data feed, especially DEX market data, to be communicated from Binance DEX to BSC 3. Provide interface and compatibility to integrate with Ethereum, including its further upgrade, and other blockchain 4. Improve client side experience to manage wallets and use blockchain more  conveniently    ------  [1]:  BNB business practitioners may provide other benefits for BNB delegators, as they do now for long term BNB holders.

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 8) heru299/script-copy

- Repo: https://github.com/heru299/script-copy
- Stars: 17
- License: üß® GPL-3.0
- Language: N/A
- Updated: 2025-12-06T11:52:49Z
- Description: -?        Print this help message and exit    -alertnotify=<cmd>        Execute command when a relevant alert is received or we see a really        long fork (%s in cmd is replaced by message)    -assumevalid=<hex>        If this block is in the chain assume that it and its ancestors are valid        and potentially skip their script verification (0 to verify all,        default:        0000000000000000000b9d2ec5a352ecba0592946514a92f14319dc2b367fc72,        testnet:        000000000000006433d1efec504c53ca332b64963c425395515b01977bd7b3b0,        signet:        0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)    -blockfilterindex=<type>        Maintain an index of compact filters by block (default: 0, values:        basic). If <type> is not supplied or if <type> = 1, indexes for        all known types are enabled.    -blocknotify=<cmd>        Execute command when the best block changes (%s in cmd is replaced by        block hash)    -blockreconstructionextratxn=<n>        Extra transactions to keep in memory for compact block reconstructions        (default: 100)    -blocksdir=<dir>        Specify directory to hold blocks subdirectory for *.dat files (default:        <datadir>)    -blocksonly        Whether to reject transactions from network peers. Automatic broadcast        and rebroadcast of any transactions from inbound peers is        disabled, unless the peer has the 'forcerelay' permission. RPC        transactions are not affected. (default: 0)    -conf=<file>        Specify path to read-only configuration file. Relative paths will be        prefixed by datadir location. (default: bitcoin.conf)    -daemon        Run in the background as a daemon and accept commands    -datadir=<dir>        Specify data directory    -dbcache=<n>        Maximum database cache size <n> MiB (4 to 16384, default: 450). In        addition, unused mempool memory is shared for this cache (see        -maxmempool).    -debuglogfile=<file>        Specify location of debug log file. Relative paths will be prefixed by a        net-specific datadir location. (-nodebuglogfile to disable;        default: debug.log)    -includeconf=<file>        Specify additional configuration file, relative to the -datadir path        (only useable from configuration file, not command line)    -loadblock=<file>        Imports blocks from external file on startup    -maxmempool=<n>        Keep the transaction memory pool below <n> megabytes (default: 300)    -maxorphantx=<n>        Keep at most <n> unconnectable transactions in memory (default: 100)    -mempoolexpiry=<n>        Do not keep transactions in the mempool longer than <n> hours (default:        336)    -par=<n>        Set the number of script verification threads (-8 to 15, 0 = auto, <0 =        leave that many cores free, default: 0)    -persistmempool        Whether to save the mempool on shutdown and load on restart (default: 1)    -pid=<file>        Specify pid file. Relative paths will be prefixed by a net-specific        datadir location. (default: bitcoind.pid)    -prune=<n>        Reduce storage requirements by enabling pruning (deleting) of old        blocks. This allows the pruneblockchain RPC to be called to        delete specific blocks, and enables automatic pruning of old        blocks if a target size in MiB is provided. This mode is        incompatible with -txindex and -rescan. Warning: Reverting this        setting requires re-downloading the entire blockchain. (default:        0 = disable pruning blocks, 1 = allow manual pruning via RPC,        >=550 = automatically prune block files to stay under the        specified target size in MiB)    -reindex        Rebuild chain state and block index from the blk*.dat files on disk    -reindex-chainstate        Rebuild chain state from the currently indexed blocks. When in pruning        mode or if blocks on disk might be corrupted, use full -reindex        instead.    -settings=<file>        Specify path to dynamic settings data file. Can be disabled with        -nosettings. File is written at runtime and not meant to be        edited by users (use bitcoin.conf instead for custom settings).        Relative paths will be prefixed by datadir location. (default:        settings.json)    -startupnotify=<cmd>        Execute command on startup.    -sysperms        Create new files with system default permissions, instead of umask 077        (only effective with disabled wallet functionality)    -txindex        Maintain a full transaction index, used by the getrawtransaction rpc        call (default: 0)    -version        Print version and exit  Connection options:    -addnode=<ip>        Add a node to connect to and attempt to keep the connection open (see        the `addnode` RPC command help for more info). This option can be        specified multiple times to add multiple nodes.    -asmap=<file>        Specify asn mapping used for bucketing of the peers (default:        ip_asn.map). Relative paths will be prefixed by the net-specific        datadir location.    -bantime=<n>        Default duration (in seconds) of manually configured bans (default:        86400)    -bind=<addr>[:<port>][=onion]        Bind to given address and always listen on it (default: 0.0.0.0). Use        [host]:port notation for IPv6. Append =onion to tag any incoming        connections to that address and port as incoming Tor connections        (default: 127.0.0.1:8334=onion, testnet: 127.0.0.1:18334=onion,        signet: 127.0.0.1:38334=onion, regtest: 127.0.0.1:18445=onion)    -connect=<ip>        Connect only to the specified node; -noconnect disables automatic        connections (the rules for this peer are the same as for        -addnode). This option can be specified multiple times to connect        to multiple nodes.    -discover        Discover own IP addresses (default: 1 when listening and no -externalip        or -proxy)    -dns        Allow DNS lookups for -addnode, -seednode and -connect (default: 1)    -dnsseed        Query for peer addresses via DNS lookup, if low on addresses (default: 1        unless -connect used)    -externalip=<ip>        Specify your own public address    -forcednsseed        Always query for peer addresses via DNS lookup (default: 0)    -listen        Accept connections from outside (default: 1 if no -proxy or -connect)    -listenonion        Automatically create Tor onion service (default: 1)    -maxconnections=<n>        Maintain at most <n> connections to peers (default: 125)    -maxreceivebuffer=<n>        Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)    -maxsendbuffer=<n>        Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)    -maxtimeadjustment        Maximum allowed median peer time offset adjustment. Local perspective of        time may be influenced by peers forward or backward by this        amount. (default: 4200 seconds)    -maxuploadtarget=<n>        Tries to keep outbound traffic under the given target (in MiB per 24h).        Limit does not apply to peers with 'download' permission. 0 = no        limit (default: 0)    -networkactive        Enable all P2P network activity (default: 1). Can be changed by the        setnetworkactive RPC command    -onion=<ip:port>        Use separate SOCKS5 proxy to reach peers via Tor onion services, set        -noonion to disable (default: -proxy)    -onlynet=<net>        Make outgoing connections only through network <net> (ipv4, ipv6 or        onion). Incoming connections are not affected by this option.        This option can be specified multiple times to allow multiple        networks.    -peerblockfilters        Serve compact block filters to peers per BIP 157 (default: 0)    -peerbloomfilters        Support filtering of blocks and transaction with bloom filters (default:        0)    -permitbaremultisig        Relay non-P2SH multisig (default: 1)    -port=<port>        Listen for connections on <port>. Nodes not using the default ports        (default: 8333, testnet: 18333, signet: 38333, regtest: 18444)        are unlikely to get incoming connections.    -proxy=<ip:port>        Connect through SOCKS5 proxy, set -noproxy to disable (default:        disabled)    -proxyrandomize        Randomize credentials for every proxy connection. This enables Tor        stream isolation (default: 1)    -seednode=<ip>        Connect to a node to retrieve peer addresses, and disconnect. This        option can be specified multiple times to connect to multiple        nodes.    -timeout=<n>        Specify connection timeout in milliseconds (minimum: 1, default: 5000)    -torcontrol=<ip>:<port>        Tor control port to use if onion listening enabled (default:        127.0.0.1:9051)    -torpassword=<pass>        Tor control port password (default: empty)    -upnp        Use UPnP to map the listening port (default: 0)    -whitebind=<[permissions@]addr>        Bind to the given address and add permission flags to the peers        connecting to it. Use [host]:port notation for IPv6. Allowed        permissions: bloomfilter (allow requesting BIP37 filtered blocks        and transactions), noban (do not ban for misbehavior; implies        download), forcerelay (relay transactions that are already in the        mempool; implies relay), relay (relay even in -blocksonly mode,        and unlimited transaction announcements), mempool (allow        requesting BIP35 mempool contents), download (allow getheaders        during IBD, no disconnect after maxuploadtarget limit), addr        (responses to GETADDR avoid hitting the cache and contain random        records with the most up-to-date info). Specify multiple        permissions separated by commas (default:        download,noban,mempool,relay). Can be specified multiple times.    -whitelist=<[permissions@]IP address or network>        Add permission flags to the peers connecting from the given IP address        (e.g. 1.2.3.4) or CIDR-notated network (e.g. 1.2.3.0/24). Uses        the same permissions as -whitebind. Can be specified multiple        times.  Wallet options:    -addresstype        What type of addresses to use ("legacy", "p2sh-segwit", or "bech32",        default: "bech32")    -avoidpartialspends        Group outputs by address, selecting all or none, instead of selecting on        a per-output basis. Privacy is improved as an address is only        used once (unless someone sends to it after spending from it),        but may result in slightly higher fees as suboptimal coin        selection may result due to the added limitation (default: 0        (always enabled for wallets with "avoid_reuse" enabled))    -changetype        What type of change to use ("legacy", "p2sh-segwit", or "bech32").        Default is same as -addresstype, except when        -addresstype=p2sh-segwit a native segwit output is used when        sending to a native segwit address)    -disablewallet        Do not load the wallet and disable wallet RPC calls    -discardfee=<amt>        The fee rate (in BTC/kB) that indicates your tolerance for discarding        change by adding it to the fee (default: 0.0001). Note: An output        is discarded if it is dust at this rate, but we will always        discard up to the dust relay fee and a discard fee above that is        limited by the fee estimate for the longest target    -fallbackfee=<amt>        A fee rate (in BTC/kB) that will be used when fee estimation has        insufficient data. 0 to entirely disable the fallbackfee feature.        (default: 0.00)    -keypool=<n>        Set key pool size to <n> (default: 1000). Warning: Smaller sizes may        increase the risk of losing funds when restoring from an old        backup, if none of the addresses in the original keypool have        been used.    -maxapsfee=<n>        Spend up to this amount in additional (absolute) fees (in BTC) if it        allows the use of partial spend avoidance (default: 0.00)    -mintxfee=<amt>        Fees (in BTC/kB) smaller than this are considered zero fee for        transaction creation (default: 0.00001)    -paytxfee=<amt>        Fee (in BTC/kB) to add to transactions you send (default: 0.00)    -rescan        Rescan the block chain for missing wallet transactions on startup    -spendzeroconfchange        Spend unconfirmed change when sending transactions (default: 1)    -txconfirmtarget=<n>        If paytxfee is not set, include enough fee so transactions begin        confirmation on average within n blocks (default: 6)    -wallet=<path>        Specify wallet path to load at startup. Can be used multiple times to        load multiple wallets. Path is to a directory containing wallet        data and log files. If the path is not absolute, it is        interpreted relative to <walletdir>. This only loads existing        wallets and does not create new ones. For backwards compatibility        this also accepts names of existing top-level data files in        <walletdir>.    -walletbroadcast        Make the wallet broadcast transactions (default: 1)    -walletdir=<dir>        Specify directory to hold wallets (default: <datadir>/wallets if it        exists, otherwise <datadir>)    -walletnotify=<cmd>        Execute command when a wallet transaction changes. %s in cmd is replaced        by TxID and %w is replaced by wallet name. %w is not currently        implemented on windows. On systems where %w is supported, it        should NOT be quoted because this would break shell escaping used        to invoke the command.    -walletrbf        Send transactions with full-RBF opt-in enabled (RPC only, default: 0)  ZeroMQ notification options:    -zmqpubhashblock=<address>        Enable publish hash block in <address>    -zmqpubhashblockhwm=<n>        Set publish hash block outbound message high water mark (default: 1000)    -zmqpubhashtx=<address>        Enable publish hash transaction in <address>    -zmqpubhashtxhwm=<n>        Set publish hash transaction outbound message high water mark (default:        1000)    -zmqpubrawblock=<address>        Enable publish raw block in <address>    -zmqpubrawblockhwm=<n>        Set publish raw block outbound message high water mark (default: 1000)    -zmqpubrawtx=<address>        Enable publish raw transaction in <address>    -zmqpubrawtxhwm=<n>        Set publish raw transaction outbound message high water mark (default:        1000)    -zmqpubsequence=<address>        Enable publish hash block and tx sequence in <address>    -zmqpubsequencehwm=<n>        Set publish hash sequence message high water mark (default: 1000)  Debugging/Testing options:    -debug=<category>        Output debugging information (default: -nodebug, supplying <category> is        optional). If <category> is not supplied or if <category> = 1,        output all debugging information. <category> can be: net, tor,        mempool, http, bench, zmq, walletdb, rpc, estimatefee, addrman,        selectcoins, reindex, cmpctblock, rand, prune, proxy, mempoolrej,        libevent, coindb, qt, leveldb, validation.    -debugexclude=<category>        Exclude debugging information for a category. Can be used in conjunction        with -debug=1 to output debug logs for all categories except one        or more specified categories.    -help-debug        Print help message with debugging options and exit    -logips        Include IP addresses in debug output (default: 0)    -logthreadnames        Prepend debug output with name of the originating thread (only available        on platforms supporting thread_local) (default: 0)    -logtimestamps        Prepend debug output with timestamp (default: 1)    -maxtxfee=<amt>        Maximum total fees (in BTC) to use in a single wallet transaction;        setting this too low may abort large transactions (default: 0.10)    -printtoconsole        Send trace/debug info to console (default: 1 when no -daemon. To disable        logging to file, set -nodebuglogfile)    -shrinkdebugfile        Shrink debug.log file on client startup (default: 1 when no -debug)    -uacomment=<cmt>        Append comment to the user agent string  Chain selection options:    -chain=<chain>        Use the chain <chain> (default: main). Allowed values: main, test,        signet, regtest    -signet        Use the signet chain. Equivalent to -chain=signet. Note that the network        is defined by the -signetchallenge parameter    -signetchallenge        Blocks must satisfy the given script to be considered valid (only for        signet networks; defaults to the global default signet test        network challenge)    -signetseednode        Specify a seed node for the signet network, in the hostname[:port]        format, e.g. sig.net:1234 (may be used multiple times to specify        multiple seed nodes; defaults to the global default signet test        network seed node(s))    -testnet        Use the test chain. Equivalent to -chain=test.  Node relay options:    -bytespersigop        Equivalent bytes per sigop in transactions for relay and mining        (default: 20)    -datacarrier        Relay and mine data carrier transactions (default: 1)    -datacarriersize        Maximum size of data in data carrier transactions we relay and mine        (default: 83)    -minrelaytxfee=<amt>        Fees (in BTC/kB) smaller than this are considered zero fee for relaying,        mining and transaction creation (default: 0.00001)    -whitelistforcerelay        Add 'forcerelay' permission to whitelisted inbound peers with default        permissions. This will relay transactions even if the        transactions were already in the mempool. (default: 0)    -whitelistrelay        Add 'relay' permission to whitelisted inbound peers with default        permissions. This will accept relayed transactions even when not        relaying transactions (default: 1)  Block creation options:    -blockmaxweight=<n>        Set maximum BIP141 block weight (default: 3996000)    -blockmintxfee=<amt>        Set lowest fee rate (in BTC/kB) for transactions to be included in block        creation. (default: 0.00001)  RPC server options:    -rest        Accept public REST requests (default: 0)    -rpcallowip=<ip>        Allow JSON-RPC connections from specified source. Valid for <ip> are a        single IP (e.g. 1.2.3.4), a network/netmask (e.g.        1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This        option can be specified multiple times    -rpcauth=<userpw>        Username and HMAC-SHA-256 hashed password for JSON-RPC connections. The        field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A        canonical python script is included in share/rpcauth. The client        then connects normally using the        rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This        option can be specified multiple times    -rpcbind=<addr>[:port]        Bind to given address to listen for JSON-RPC connections. Do not expose        the RPC server to untrusted networks such as the public internet!        This option is ignored unless -rpcallowip is also passed. Port is        optional and overrides -rpcport. Use [host]:port notation for        IPv6. This option can be specified multiple times (default:        127.0.0.1 and ::1 i.e., localhost)    -rpccookiefile=<loc>        Location of the auth cookie. Relative paths will be prefixed by a        net-specific datadir location. (default: data dir)    -rpcpassword=<pw>        Password for JSON-RPC connections    -rpcport=<port>        Listen for JSON-RPC connections on <port> (default: 8332, testnet:        18332, signet: 38332, regtest: 18443)    -rpcserialversion        Sets the serialization of raw transaction or block hex returned in        non-verbose mode, non-segwit(0) or segwit(1) (default: 1)    -rpcthreads=<n>        Set the number of threads to service RPC calls (default: 4)    -rpcuser=<user>        Username for JSON-RPC connections    -rpcwhitelist=<whitelist>        Set a whitelist to filter incoming RPC calls for a specific user. The        field <whitelist> comes in the format: <USERNAME>:<rpc 1>,<rpc        2>,...,<rpc n>. If multiple whitelists are set for a given user,        they are set-intersected. See -rpcwhitelistdefault documentation        for information on default whitelist behavior.    -rpcwhitelistdefault        Sets default behavior for rpc whitelisting. Unless rpcwhitelistdefault        is set to 0, if any -rpcwhitelist is set, the rpc server acts as        if all rpc users are subject to empty-unless-otherwise-specified        whitelists. If rpcwhitelistdefault is set to 1 and no        -rpcwhitelist is set, rpc server acts as if all rpc users are        subject to empty whitelists.    -server        Accept command line and JSON-RPC commands  ~ $

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 9) Mario-Coxe/audittrailjs

- Repo: https://github.com/Mario-Coxe/audittrailjs
- Stars: 13
- License: ‚ö†Ô∏è UNKNOWN
- Language: TypeScript
- Updated: 2025-12-12T03:47:08Z
- Description: AuditTrailJS is an open-source library built in JavaScript/TypeScript for Node.js applications, designed to provide a centralized and extensible layer for auditing and logging.

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

## 10) Briechenstein12/Jerusalem2020j2IL-Repository

- Repo: https://github.com/Briechenstein12/Jerusalem2020j2IL-Repository
- Stars: 12
- License: ‚ö†Ô∏è UNKNOWN
- Language: N/A
- Updated: 2025-10-04T16:39:13Z
- Description: Search documentation... Support Dashboard Card Payments Quickstart Securely collect card information from your customers and create a card payment.  Supported cards Users in the United States can accept Visa Mastercard American Express Discover JCB Diners Club credit and debit cards.  Stripe also supports a range of additional payment methods, depending on the country of your Stripe account.  Accepting a card payment using Stripe is a two-step process, with a client-side and a server-side action:  From your website running in the customer‚Äôs browser, Stripe securely collects your customer‚Äôs payment information and returns a representative token. This, along with any other form data, is then submitted by the browser to your server. Using the token, your server-side code makes an API request to create a charge and complete the payment. Tokenization ensures that no sensitive card data ever needs to touch your server so your integration can operate in a PCI compliant way.  Step 1: Securely collecting payment information  Checkout reference Complete information about available options and parameters is provided in the Checkout reference.  The simplest way for you to securely collect and tokenize card information is with Checkout. It combines HTML, JavaScript, and CSS to create an embedded payment form. When your customer enters their payment information, the card details are validated and tokenized for your server-side code to use.  To see Checkout in action, click the button below, filling in the resulting form with:  Any random, syntactically valid email address (the more random, the better) One of Stripe‚Äôs test card numbers, such as 4242 4242 4242 4242 Any three-digit CVC code Any expiration date in the future To get started, add the following code to your payment page, making sure that the form submits to your own server-side code:  <form action="your-server-side-code" method="POST">   <script     src="https://checkout.stripe.com/checkout.js" class="stripe-button"     data-key="pk_test_2DtHIU1N9li5GpmJjyxkQMHh"     data-amount="999"     data-name="Demo Site"     data-description="Example charge"     data-image="https://stripe.com/img/documentation/checkout/marketplace.png"     data-locale="auto">   </script> </form> We‚Äôve pre-filled the data-key attribute with your test publishable API key‚Äîonly you can see this value. When you‚Äôre ready to go live with your payment form, you must replace the test key with your live key. Learn more about how the keys play into test and live modes.  Although optional, we highly recommend also having Checkout collect the user‚Äôs ZIP code, as address and ZIP code verifications help reduce fraud. Add data-zip-code="true" to the above and enable declines on verification failures in your account settings. You can also set Checkout to collect the user‚Äôs full billing and shipping addresses (using the corresponding parameters).  Requiring more than the minimum information lowers the possibility of a payment being declined or disputed in the future. Any fraudulent payments that you process are ultimately your responsibility, so requiring a little more than the minimum amount of information is an effective way to combat fraud.  Radar, our modern suite of fraud protection tools, is only available to users who have implemented client-side tokenization. By doing so, it ensures that you can pass the necessary data required for our machine-learning fraud prevention models to make more accurate predictions.  The amount provided in the Checkout form code is only shown to the user. It does not set the amount that the customer will be charged‚Äîyou must also specify an amount when making a charge request. As you build your integration, make sure that your payment form and server-side code use the same amount to avoid confusion.  An alternative to the blue button demonstrated above is to implement a custom Checkout integration. The custom approach allows you to use any HTML element or JavaScript event to open Checkout, as well as be able to specify dynamic arguments, such as custom amounts.  Stripe.js and Elements If you‚Äôd prefer to have complete control over the look and fel of your payment form, you can make use of Stripe.js and Elements, our pre-built UI components. Refer to our Elements quickstart to learn more.  Mobile SDKs Using our native mobile libraries for iOS and Android, Stripe can collect your customer‚Äôs payment information from within your mobile app and create a token for your server-side code to use.  Step 2: Creating a charge to complete the payment  Once a token is created, your server-side code makes an API request to create a one-time charge. This request contains the token, currency, amount to charge, and any additional information you may want to pass (e.g., metadata).  curl Ruby Python PHP Java Node Go .NET curl https://api.stripe.com/v1/charges \    -u sk_test_fyzWf8eDyljIob76fMVSwIsi: \    -d amount=999 \    -d currency=usd \    -d description="Example charge" \    -d source=tok_6Pk6W3hFiGB7dyNavdvyrFkM These requests expect the ID of the Token (e.g., tok_KPte7942xySKBKyrBu11yEpf) to be provided as the value of the source parameter.  Tokens can only be used once, and within a few minutes of creation. Using this approach, your customers need to re-enter their payment details each time they make a purchase. You can also save card details with Stripe for later use. Using this method, returning customers can quickly make a payment without providing their card details again.  Next steps Congrats! You can now accept card payments with Stripe using Checkout. You may now want to check out these resources:  Creating charges Getting paid Managing your Stripe account Supported payment methods Saving cards Questions? We're always happy to help with code or other questions you might have! Search our documentation, contact support, or connect with our sales team. You can also chat live with other developers in #stripe on freenode.  Was this page helpful? Yes No

Integration notes (fill):
- What we‚Äôd use it for:
- 1 day POC:
- 1 week integration:
- Risks:

